<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title></title>
  <link rel="stylesheet" href="static/css/rfc.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1></h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-'>
      <td class=docs>
        <p class="rfcparagraph"><p>Network Working Group                                    S. Blake-Wilson<br>Request for Comments: 4492                                       SafeNet<br>Category: Informational                                       N. Bolyard<br>                                                        Sun Microsystems<br>                                                                V. Gupta<br>                                                                Sun Labs<br>                                                                 C. Hawk<br>                                                               Corriente<br>                                                              B. Moeller<br>                                                         Ruhr-Uni Bochum<br>                                                                May 2006<br><br></p>
                  <h1>
            Elliptic Curve Cryptography (ECC) Cipher Suites
                   for Transport Layer Security (TLS)</h1>
                  <h2>Status of This Memo</h2>

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

</p><p class="rfcparagraph"><h2>Copyright Notice</h2>

   Copyright (C) The Internet Society (2006).<br>

</p><p class="rfcparagraph"><h2>Abstract</h2>

   This document describes new key exchange algorithms based on Elliptic
   Curve Cryptography (ECC) for the Transport Layer Security (TLS)
   protocol.  In particular, it specifies the use of Elliptic Curve
   Diffie-Hellman (ECDH) key agreement in a TLS handshake and the use of
   Elliptic Curve Digital Signature Algorithm (ECDSA) as a new
   authentication mechanism.
<h2>Table of Contents</h2>
<a href="#section-1" class="">1. Introduction ...................................................</a><br>
<a href="#section-2" class="">2. Key Exchange Algorithms ........................................</a><br>
<a href="#section-2.1" class="indent-1">2.1. ECDH_ECDSA ................................................</a><br>
<a href="#section-2.2" class="indent-1">2.2. ECDHE_ECDSA ...............................................</a><br>
<a href="#section-2.3" class="indent-1">2.3. ECDH_RSA ..................................................</a><br>
<a href="#section-2.4" class="indent-1">2.4. ECDHE_RSA .................................................</a><br>
<a href="#section-2.5" class="indent-1">2.5. ECDH_anon .................................................</a><br>
<a href="#section-3" class="">3. Client Authentication ..........................................</a><br>
<a href="#section-3.1" class="indent-1">3.1. ECDSA_sign ................................................</a><br>
<a href="#section-3.2" class="indent-1">3.2. ECDSA_fixed_ECDH ..........................................</a><br>
<a href="#section-3.3" class="indent-1">3.3. RSA_fixed_ECDH ............................................</a><br>
<a href="#section-4" class="">4. TLS Extensions for ECC .........................................</a><br>
<a href="#section-5" class="">5. Data Structures and Computations ..............................</a><br>
<a href="#section-5.1" class="indent-1">5.1. Client Hello Extensions ..................................</a><br>
<a href="#section-5.1.1" class="indent-2">5.1.1. Supported Elliptic Curves Extension ...............</a><br>
<a href="#section-5.1.2" class="indent-2">5.1.2. Supported Point Formats Extension .................</a><br>
<a href="#section-5.2" class="indent-1">5.2. Server Hello Extension ...................................</a><br>
<a href="#section-5.3" class="indent-1">5.3. Server Certificate .......................................</a><br>
<a href="#section-5.4" class="indent-1">5.4. Server Key Exchange ......................................</a><br>
<a href="#section-5.5" class="indent-1">5.5. Certificate Request ......................................</a><br>
<a href="#section-5.6" class="indent-1">5.6. Client Certificate .......................................</a><br>
<a href="#section-5.7" class="indent-1">5.7. Client Key Exchange ......................................</a><br>
<a href="#section-5.8" class="indent-1">5.8. Certificate Verify .......................................</a><br>
<a href="#section-5.9" class="indent-1">5.9. Elliptic Curve Certificates ..............................</a><br>
<a href="#section-5.10" class="indent-1">5.10. ECDH, ECDSA, and RSA Computations .......................</a><br>
<a href="#section-6" class="">6. Cipher Suites .................................................</a><br>
<a href="#section-7" class="">7. Security Considerations .......................................</a><br>
<a href="#section-8" class="">8. IANA Considerations ...........................................</a><br>
<a href="#section-9" class="">9. Acknowledgements ..............................................</a><br>
<a href="#section-10" class="">10. References ...................................................</a><br>
<a href="#section-10.1" class="indent-1">10.1. Normative References ....................................</a><br>
<a href="#section-10.2" class="indent-1">10.2. Informative References ..................................</a><br>
   Appendix A.  Equivalent Curves (Informative) ......................32
	<a name="section-1"><h2>1.   Introduction</h2></a>

   Elliptic Curve Cryptography (ECC) is emerging as an attractive
   public-key cryptosystem, in particular for mobile (i.e., wireless)
   environments.  Compared to currently prevalent cryptosystems such as
   RSA, ECC offers equivalent security with smaller key sizes.  This is
   illustrated in the following table, based on [18], which gives
   approximate comparable key sizes for symmetric- and asymmetric-key
   cryptosystems based on the best-known algorithms for attacking them.

</p><p class="rfcparagraph">                    Symmetric  |   ECC   |  DH/DSA/RSA
                   ------------<pre>+---------+-------------
                        80     |   163   |     1024
                       112     |   233   |     2048
                       128     |   283   |     3072
                       192     |   409   |     7680
                       256     |   571   |    15360

                  Table 1: Comparable Key Sizes (in bits)

   Smaller key sizes result in savings for power, memory, bandwidth, and
   computational cost that make ECC especially attractive for
   constrained environments.

</p><p class="rfcparagraph">   This document describes additions to TLS to support ECC, applicable
   both to TLS Version 1.0 [2] and to TLS Version 1.1 [3].  In
   particular, it defines

   o  the use of the Elliptic Curve Diffie-Hellman (ECDH) key agreement
      scheme with long-term or ephemeral keys to establish the TLS
      premaster secret, and

   o  the use of fixed-ECDH certificates and ECDSA for authentication of
      TLS peers.

</p><p class="rfcparagraph">   The remainder of this document is organized as follows.  Section 2
   provides an overview of ECC-based key exchange algorithms for TLS.
   Section 3 describes the use of ECC certificates for client
   authentication.  TLS extensions that allow a client to negotiate the
   use of specific curves and point formats are presented in Section 4.
   Section 5 specifies various data structures needed for an ECC-based
   handshake, their encoding in TLS messages, and the processing of
   those messages.  Section 6 defines new ECC-based cipher suites and
   identifies a small subset of these as recommended for all
   implementations of this specification.  Section 7 discusses security
   considerations.  Section 8 describes IANA considerations for the name
   spaces created by this document.  Section 9 gives acknowledgements.
   This is followed by the lists of normative and informative references
   cited in this document, the authors' contact information, and
   statements on intellectual property rights and copyrights.

</p><p class="rfcparagraph">   Implementation of this specification requires familiarity with TLS
   [2][3], TLS extensions [4], and ECC [5][6][7][11][17].

</p><p class="rfcparagraph">   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC 2119 [1].

</p><p class="rfcparagraph">	<a name="section-2"><h2>2.   Key Exchange Algorithms</h2></a>

   This document introduces five new ECC-based key exchange algorithms
   for TLS.  All of them use ECDH to compute the TLS premaster secret,
   and they differ only in the lifetime of ECDH keys (long-term or
   ephemeral) and the mechanism (if any) used to authenticate them.  The
   derivation of the TLS master secret from the premaster secret and the
   subsequent generation of bulk encryption/MAC keys and initialization
   vectors is independent of the key exchange algorithm and not impacted
   by the introduction of ECC.

</p><p class="rfcparagraph">   The table below summarizes the new key exchange algorithms, which
   mimic DH_DSS, DHE_DSS, DH_RSA, DHE_RSA, and DH_anon (see [2] and
   [3]), respectively.

</p><p class="rfcparagraph">          Key
          Exchange
          Algorithm           Description
          ---------           -----------

          ECDH_ECDSA          Fixed ECDH with ECDSA-signed certificates.

</p><p class="rfcparagraph">          ECDHE_ECDSA         Ephemeral ECDH with ECDSA signatures.

</p><p class="rfcparagraph">          ECDH_RSA            Fixed ECDH with RSA-signed certificates.

</p><p class="rfcparagraph">          ECDHE_RSA           Ephemeral ECDH with RSA signatures.

</p><p class="rfcparagraph">          ECDH_anon           Anonymous ECDH, no signatures.

</p><p class="rfcparagraph">                     Table 2: ECC Key Exchange Algorithms

   The ECDHE_ECDSA and ECDHE_RSA key exchange mechanisms provide forward
   secrecy.  With ECDHE_RSA, a server can reuse its existing RSA
   certificate and easily comply with a constrained client's elliptic
   curve preferences (see Section 4).  However, the computational cost
   incurred by a server is higher for ECDHE_RSA than for the traditional
   RSA key exchange, which does not provide forward secrecy.

</p><p class="rfcparagraph">   The ECDH_RSA mechanism requires a server to acquire an ECC
   certificate, but the certificate issuer can still use an existing RSA
   key for signing.  This eliminates the need to update the keys of
   trusted certification authorities accepted by TLS clients.  The
   ECDH_ECDSA mechanism requires ECC keys for the server as well as the
   certification authority and is best suited for constrained devices
   unable to support RSA.

</p><p class="rfcparagraph">   The anonymous key exchange algorithm does not provide authentication
   of the server or the client.  Like other anonymous TLS key exchanges,
   it is subject to man-in-the-middle attacks.  Implementations of this
   algorithm SHOULD provide authentication by other means.

</p><p class="rfcparagraph">   Note that there is no structural difference between ECDH and ECDSA
   keys.  A certificate issuer may use X.509 v3 keyUsage and
   extendedKeyUsage extensions to restrict the use of an ECC public key
   to certain computations [15].  This document refers to an ECC key as
   ECDH-capable if its use in ECDH is permitted.  ECDSA-capable is
   defined similarly.

</p><p class="rfcparagraph">              Client                                        Server
              ------                                        ------

              ClientHello          -------->
                                                       ServerHello
                                                      Certificate*
                                                ServerKeyExchange*
                                              CertificateRequest*+
                                   <--------       ServerHelloDone
              Certificate*+
              ClientKeyExchange
              CertificateVerify*+
              [ChangeCipherSpec]
              Finished             -------->
                                                [ChangeCipherSpec]
                                   <--------              Finished

              Application Data     <------->      Application Data


                   * message is not sent under some conditions
                   + message is not sent unless client authentication
                     is desired

                 Figure 1: Message flow in a full TLS handshake
   Figure 1 shows all messages involved in the TLS key establishment
   protocol (aka full handshake).  The addition of ECC has direct impact
   only on the ClientHello, the ServerHello, the server's Certificate
   message, the ServerKeyExchange, the ClientKeyExchange, the
   CertificateRequest, the client's Certificate message, and the
   CertificateVerify.  Next, we describe each ECC key exchange algorithm
   in greater detail in terms of the content and processing of these
   messages.  For ease of exposition, we defer discussion of client
   authentication and associated messages (identified with a + in
   Figure 1) until Section 3 and of the optional ECC-specific extensions
   (which impact the Hello messages) until Section 4.

</p><p class="rfcparagraph">	<a name="section-2.1"><h3>2.1   ECDH_ECDSA</h3></a>

   In ECDH_ECDSA, the server's certificate MUST contain an ECDH-capable
   public key and be signed with ECDSA.

</p><p class="rfcparagraph">   A ServerKeyExchange MUST NOT be sent (the server's certificate
   contains all the necessary keying information required by the client
   to arrive at the premaster secret).

</p><p class="rfcparagraph">   The client generates an ECDH key pair on the same curve as the
   server's long-term public key and sends its public key in the
   ClientKeyExchange message (except when using client authentication
   algorithm ECDSA_fixed_ECDH or RSA_fixed_ECDH, in which case the
   modifications from Section 3.2 or Section 3.3 apply).

</p><p class="rfcparagraph">   Both client and server perform an ECDH operation and use the
   resultant shared secret as the premaster secret.  All ECDH
   calculations are performed as specified in Section 5.10.

</p><p class="rfcparagraph">	<a name="section-2.2"><h3>2.2   ECDHE_ECDSA</h3></a>

   In ECDHE_ECDSA, the server's certificate MUST contain an ECDSA-
   capable public key and be signed with ECDSA.

</p><p class="rfcparagraph">   The server sends its ephemeral ECDH public key and a specification of
   the corresponding curve in the ServerKeyExchange message.  These
   parameters MUST be signed with ECDSA using the private key
   corresponding to the public key in the server's Certificate.

</p><p class="rfcparagraph">   The client generates an ECDH key pair on the same curve as the
   server's ephemeral ECDH key and sends its public key in the
   ClientKeyExchange message.

</p><p class="rfcparagraph">   Both client and server perform an ECDH operation (Section 5.10) and
   use the resultant shared secret as the premaster secret.
	<a name="section-2.3"><h3>2.3   ECDH_RSA</h3></a>

   This key exchange algorithm is the same as ECDH_ECDSA except that the
   server's certificate MUST be signed with RSA rather than ECDSA.

</p><p class="rfcparagraph">	<a name="section-2.4"><h3>2.4   ECDHE_RSA</h3></a>

   This key exchange algorithm is the same as ECDHE_ECDSA except that
   the server's certificate MUST contain an RSA public key authorized
   for signing, and that the signature in the ServerKeyExchange message
   must be computed with the corresponding RSA private key.  The server
   certificate MUST be signed with RSA.

</p><p class="rfcparagraph">	<a name="section-2.5"><h3>2.5   ECDH_anon</h3></a>

   In ECDH_anon, the server's Certificate, the CertificateRequest, the
   client's Certificate, and the CertificateVerify messages MUST NOT be
   sent.

</p><p class="rfcparagraph">   The server MUST send an ephemeral ECDH public key and a specification
   of the corresponding curve in the ServerKeyExchange message.  These
   parameters MUST NOT be signed.

</p><p class="rfcparagraph">   The client generates an ECDH key pair on the same curve as the
   server's ephemeral ECDH key and sends its public key in the
   ClientKeyExchange message.

</p><p class="rfcparagraph">   Both client and server perform an ECDH operation and use the
   resultant shared secret as the premaster secret.  All ECDH
   calculations are performed as specified in Section 5.10.

</p><p class="rfcparagraph">   Note that while the ECDH_ECDSA, ECDHE_ECDSA, ECDH_RSA, and ECDHE_RSA
   key exchange algorithms require the server's certificate to be signed
   with a particular signature scheme, this specification (following the
   similar cases of DH_DSS, DHE_DSS, DH_RSA, and DHE_RSA in [2] and [3])
   does not impose restrictions on signature schemes used elsewhere in
   the certificate chain.  (Often such restrictions will be useful, and
   it is expected that this will be taken into account in certification
   authorities' signing practices.  However, such restrictions are not
   strictly required in general: Even if it is beyond the capabilities
   of a client to completely validate a given chain, the client may be
   able to validate the server's certificate by relying on a trusted
   certification authority whose certificate appears as one of the
   intermediate certificates in the chain.)
	<a name="section-3"><h2>3.   Client Authentication</h2></a>

   This document defines three new client authentication mechanisms,
   each named after the type of client certificate involved: ECDSA_sign,
   ECDSA_fixed_ECDH, and RSA_fixed_ECDH.  The ECDSA_sign mechanism is
   usable with any of the non-anonymous ECC key exchange algorithms
   described in Section 2 as well as other non-anonymous (non-ECC) key
   exchange algorithms defined in TLS [2][3].  The ECDSA_fixed_ECDH and
   RSA_fixed_ECDH mechanisms are usable with ECDH_ECDSA and ECDH_RSA.
   Their use with ECDHE_ECDSA and ECDHE_RSA is prohibited because the
   use of a long-term ECDH client key would jeopardize the forward
   secrecy property of these algorithms.

</p><p class="rfcparagraph">   The server can request ECC-based client authentication by including
   one or more of these certificate types in its CertificateRequest
   message.  The server must not include any certificate types that are
   prohibited for the negotiated key exchange algorithm.  The client
   must check if it possesses a certificate appropriate for any of the
   methods suggested by the server and is willing to use it for
   authentication.

</p><p class="rfcparagraph">   If these conditions are not met, the client should send a client
   Certificate message containing no certificates.  In this case, the
   ClientKeyExchange should be sent as described in Section 2, and the
   CertificateVerify should not be sent.  If the server requires client
   authentication, it may respond with a fatal handshake failure alert.

</p><p class="rfcparagraph">   If the client has an appropriate certificate and is willing to use it
   for authentication, it must send that certificate in the client's
   Certificate message (as per Section 5.6) and prove possession of the
   private key corresponding to the certified key.  The process of
   determining an appropriate certificate and proving possession is
   different for each authentication mechanism and described below.

</p><p class="rfcparagraph">   NOTE: It is permissible for a server to request (and the client to
   send) a client certificate of a different type than the server
   certificate.

</p><p class="rfcparagraph">	<a name="section-3.1"><h3>3.1   ECDSA_sign</h3></a>

   To use this authentication mechanism, the client MUST possess a
   certificate containing an ECDSA-capable public key and signed with
   ECDSA.

</p><p class="rfcparagraph">   The client proves possession of the private key corresponding to the
   certified key by including a signature in the CertificateVerify
   message as described in Section 5.8.
	<a name="section-3.2"><h3>3.2   ECDSA_fixed_ECDH</h3></a>

   To use this authentication mechanism, the client MUST possess a
   certificate containing an ECDH-capable public key, and that
   certificate MUST be signed with ECDSA.  Furthermore, the client's
   ECDH key MUST be on the same elliptic curve as the server's long-term
   (certified) ECDH key.  This might limit use of this mechanism to
   closed environments.  In situations where the client has an ECC key
   on a different curve, it would have to authenticate using either
   ECDSA_sign or a non-ECC mechanism (e.g., RSA).  Using fixed ECDH for
   both servers and clients is computationally more efficient than
   mechanisms providing forward secrecy.

</p><p class="rfcparagraph">   When using this authentication mechanism, the client MUST send an
   empty ClientKeyExchange as described in Section 5.7 and MUST NOT send
   the CertificateVerify message.  The ClientKeyExchange is empty since
   the client's ECDH public key required by the server to compute the
   premaster secret is available inside the client's certificate.  The
   client's ability to arrive at the same premaster secret as the server
   (demonstrated by a successful exchange of Finished messages) proves
   possession of the private key corresponding to the certified public
   key, and the CertificateVerify message is unnecessary.

</p><p class="rfcparagraph">	<a name="section-3.3"><h3>3.3   RSA_fixed_ECDH</h3></a>

   This authentication mechanism is identical to ECDSA_fixed_ECDH except
   that the client's certificate MUST be signed with RSA.

</p><p class="rfcparagraph">   Note that while the ECDSA_sign, ECDSA_fixed_ECDH, and RSA_fixed_ECDH
   client authentication mechanisms require the client's certificate to
   be signed with a particular signature scheme, this specification does
   not impose restrictions on signature schemes used elsewhere in the
   certificate chain.  (Often such restrictions will be useful, and it
   is expected that this will be taken into account in certification
   authorities' signing practices.  However, such restrictions are not
   strictly required in general: Even if it is beyond the capabilities
   of a server to completely validate a given chain, the server may be
   able to validate the clients certificate by relying on a trust anchor
   that appears as one of the intermediate certificates in the chain.)

	<a name="section-4"><h2>4.   TLS Extensions for ECC</h2></a>

   Two new TLS extensions are defined in this specification: (i) the
   Supported Elliptic Curves Extension, and (ii) the Supported Point
   Formats Extension.  These allow negotiating the use of specific
   curves and point formats (e.g., compressed vs. uncompressed,
   respectively) during a handshake starting a new session.  These
   extensions are especially relevant for constrained clients that may
   only support a limited number of curves or point formats.  They
   follow the general approach outlined in [4]; message details are
   specified in Section 5.  The client enumerates the curves it supports
   and the point formats it can parse by including the appropriate
   extensions in its ClientHello message.  The server similarly
   enumerates the point formats it can parse by including an extension
   in its ServerHello message.

</p><p class="rfcparagraph">   A TLS client that proposes ECC cipher suites in its ClientHello
   message SHOULD include these extensions.  Servers implementing ECC
   cipher suites MUST support these extensions, and when a client uses
   these extensions, servers MUST NOT negotiate the use of an ECC cipher
   suite unless they can complete the handshake while respecting the
   choice of curves and compression techniques specified by the client.
   This eliminates the possibility that a negotiated ECC handshake will
   be subsequently aborted due to a client's inability to deal with the
   server's EC key.

</p><p class="rfcparagraph">   The client MUST NOT include these extensions in the ClientHello
   message if it does not propose any ECC cipher suites.  A client that
   proposes ECC cipher suites may choose not to include these
   extensions.  In this case, the server is free to choose any one of
   the elliptic curves or point formats listed in Section 5.  That
   section also describes the structure and processing of these
   extensions in greater detail.

</p><p class="rfcparagraph">   In the case of session resumption, the server simply ignores the
   Supported Elliptic Curves Extension and the Supported Point Formats
   Extension appearing in the current ClientHello message.  These
   extensions only play a role during handshakes negotiating a new
   session.

</p><p class="rfcparagraph">	<a name="section-5"><h2>5.   Data Structures and Computations</h2></a>

   This section specifies the data structures and computations used by
   ECC-based key mechanisms specified in Sections 2, 3, and 4.  The
   presentation language used here is the same as that used in TLS
   [2][3].  Since this specification extends TLS, these descriptions
   should be merged with those in the TLS specification and any others
   that extend TLS.  This means that enum types may not specify all
   possible values, and structures with multiple formats chosen with a
   select() clause may not indicate all possible cases.

</p><p class="rfcparagraph">	<a name="section-5.1"><h3>5.1   Client Hello Extensions</h3></a>

   This section specifies two TLS extensions that can be included with
   the ClientHello message as described in [4], the Supported Elliptic
   Curves Extension and the Supported Point Formats Extension.
   When these extensions are sent:

</p><p class="rfcparagraph">   The extensions SHOULD be sent along with any ClientHello message that
   proposes ECC cipher suites.

</p><p class="rfcparagraph">   Meaning of these extensions:

</p><p class="rfcparagraph">   These extensions allow a client to enumerate the elliptic curves it
   supports and/or the point formats it can parse.

</p><p class="rfcparagraph">   Structure of these extensions:

</p><p class="rfcparagraph">   The general structure of TLS extensions is described in [4], and this
   specification adds two new types to ExtensionType.

</p><p class="rfcparagraph">       enum { elliptic_curves(10), ec_point_formats(11) } ExtensionType;<br>

</p><p class="rfcparagraph">   elliptic_curves (Supported Elliptic Curves Extension):   Indicates
      the set of elliptic curves supported by the client.  For this
      extension, the opaque extension_data field contains
      EllipticCurveList.  See Section 5.1.1 for details.

</p><p class="rfcparagraph">   ec_point_formats (Supported Point Formats Extension):   Indicates the
      set of point formats that the client can parse.  For this
      extension, the opaque extension_data field contains
      ECPointFormatList.  See Section 5.1.2 for details.

</p><p class="rfcparagraph">   Actions of the sender:

</p><p class="rfcparagraph">   A client that proposes ECC cipher suites in its ClientHello message
   appends these extensions (along with any others), enumerating the
   curves it supports and the point formats it can parse.  Clients
   SHOULD send both the Supported Elliptic Curves Extension and the
   Supported Point Formats Extension.  If the Supported Point Formats
   Extension is indeed sent, it MUST contain the value 0 (uncompressed)
   as one of the items in the list of point formats.

</p><p class="rfcparagraph">   Actions of the receiver:

</p><p class="rfcparagraph">   A server that receives a ClientHello containing one or both of these
   extensions MUST use the client's enumerated capabilities to guide its
   selection of an appropriate cipher suite.  One of the proposed ECC
   cipher suites must be negotiated only if the server can successfully
   complete the handshake while using the curves and point formats
   supported by the client (cf. Sections 5.3 and 5.4).
   NOTE: A server participating in an ECDHE-ECDSA key exchange may use
   different curves for (i) the ECDSA key in its certificate, and (ii)
   the ephemeral ECDH key in the ServerKeyExchange message.  The server
   must consider the extensions in both cases.

</p><p class="rfcparagraph">   If a server does not understand the Supported Elliptic Curves
   Extension, does not understand the Supported Point Formats Extension,
   or is unable to complete the ECC handshake while restricting itself
   to the enumerated curves and point formats, it MUST NOT negotiate the
   use of an ECC cipher suite.  Depending on what other cipher suites
   are proposed by the client and supported by the server, this may
   result in a fatal handshake failure alert due to the lack of common
   cipher suites.

</p><p class="rfcparagraph">	<a name="section-5.1.1"><h4>5.1.1   Supported Elliptic Curves Extension</h4></a>

        enum {
            sect163k1 (1), sect163r1 (2), sect163r2 (3),<br>
            sect193r1 (4), sect193r2 (5), sect233k1 (6),<br>
            sect233r1 (7), sect239k1 (8), sect283k1 (9),<br>
            sect283r1 (10), sect409k1 (11), sect409r1 (12),<br>
            sect571k1 (13), sect571r1 (14), secp160k1 (15),<br>
            secp160r1 (16), secp160r2 (17), secp192k1 (18),<br>
            secp192r1 (19), secp224k1 (20), secp224r1 (21),<br>
            secp256k1 (22), secp256r1 (23), secp384r1 (24),<br>
            secp521r1 (25),<br>
            reserved (0xFE00..0xFEFF),
            arbitrary_explicit_prime_curves(0xFF01),
            arbitrary_explicit_char2_curves(0xFF02),
            (0xFFFF)
        } NamedCurve;

</p><p class="rfcparagraph">   sect163k1, etc:   Indicates support of the corresponding named curve
      or class of explicitly defined curves.  The named curves defined
      here are those specified in SEC 2 [13].  Note that many of these
      curves are also recommended in ANSI X9.62 [7] and FIPS 186-2 [11].
      Values 0xFE00 through 0xFEFF are reserved for private use.  Values
      0xFF01 and 0xFF02 indicate that the client supports arbitrary
      prime and characteristic-2 curves, respectively (the curve
      parameters must be encoded explicitly in ECParameters).

</p><p class="rfcparagraph">   The NamedCurve name space is maintained by IANA.  See Section 8 for
   information on how new value assignments are added.

</p><p class="rfcparagraph">        struct {
            NamedCurve elliptic_curve_list<1..2^16-1>
        } EllipticCurveList;
   Items in elliptic_curve_list are ordered according to the client's
   preferences (favorite choice first).

</p><p class="rfcparagraph">   As an example, a client that only supports secp192r1 (aka NIST P-192;
   value 19 = 0x0013) and secp224r1 (aka NIST P-224; value 21 = 0x0015)
   and prefers to use secp192r1 would include a TLS extension consisting
   of the following octets.  Note that the first two octets indicate the
   extension type (Supported Elliptic Curves Extension):

</p><p class="rfcparagraph">        00 0A 00 06 00 04 00 13 00 15

   A client that supports arbitrary explicit characteristic-2 curves
   (value 0xFF02) would include an extension consisting of the following
   octets:

</p><p class="rfcparagraph">        00 0A 00 04 00 02 FF 02

	<a name="section-5.1.2"><h4>5.1.2   Supported Point Formats Extension</h4></a>

        enum { uncompressed (0), ansiX962_compressed_prime (1),<br>
               ansiX962_compressed_char2 (2), reserved (248..255)<br>
        } ECPointFormat;

</p><p class="rfcparagraph">        struct {
            ECPointFormat ec_point_format_list<1..2^8-1>
        } ECPointFormatList;

</p><p class="rfcparagraph">   Three point formats are included in the definition of ECPointFormat
   above.  The uncompressed point format is the default format in that
   implementations of this document MUST support it for all of their
   supported curves.  Compressed point formats reduce bandwidth by
   including only the x-coordinate and a single bit of the y-coordinate
   of the point.  Implementations of this document MAY support the
   ansiX962_compressed_prime and ansiX962_compressed_char2 formats,
   where the former applies only to prime curves and the latter applies
   only to characteristic-2 curves.  (These formats are specified in
   [7].)  Values 248 through 255 are reserved for private use.

</p><p class="rfcparagraph">   The ECPointFormat name space is maintained by IANA.  See Section 8
   for information on how new value assignments are added.

</p><p class="rfcparagraph">   Items in ec_point_format_list are ordered according to the client's
   preferences (favorite choice first).
   A client that can parse only the uncompressed point format (value 0)
   includes an extension consisting of the following octets; note that
   the first two octets indicate the extension type (Supported Point
   Formats Extension):

</p><p class="rfcparagraph">        00 0B 00 02 01 00

   A client that in the case of prime fields prefers the compressed
   format (ansiX962_compressed_prime, value 1) over the uncompressed
   format (value 0), but in the case of characteristic-2 fields prefers
   the uncompressed format (value 0) over the compressed format
   (ansiX962_compressed_char2, value 2), may indicate these preferences
   by including an extension consisting of the following octets:

</p><p class="rfcparagraph">        00 0B 00 04 03 01 00 02

	<a name="section-5.2"><h3>5.2   Server Hello Extension</h3></a>

   This section specifies a TLS extension that can be included with the
   ServerHello message as described in [4], the Supported Point Formats
   Extension.

</p><p class="rfcparagraph">   When this extension is sent:

</p><p class="rfcparagraph">   The Supported Point Formats Extension is included in a ServerHello
   message in response to a ClientHello message containing the Supported
   Point Formats Extension when negotiating an ECC cipher suite.

</p><p class="rfcparagraph">   Meaning of this extension:

</p><p class="rfcparagraph">   This extension allows a server to enumerate the point formats it can
   parse (for the curve that will appear in its ServerKeyExchange
   message when using the ECDHE_ECDSA, ECDHE_RSA, or ECDH_anon key
   exchange algorithm, or for the curve that is used in the server's
   public key that will appear in its Certificate message when using the
   ECDH_ECDSA or ECDH_RSA key exchange algorithm).

</p><p class="rfcparagraph">   Structure of this extension:

</p><p class="rfcparagraph">   The server's Supported Point Formats Extension has the same structure
   as the client's Supported Point Formats Extension (see
   Section 5.1.2).  Items in elliptic_curve_list here are ordered
   according to the server's preference (favorite choice first).  Note
   that the server may include items that were not found in the client's
   list (e.g., the server may prefer to receive points in compressed
   format even when a client cannot parse this format: the same client
   may nevertheless be capable of outputting points in compressed
   format).
   Actions of the sender:

</p><p class="rfcparagraph">   A server that selects an ECC cipher suite in response to a
   ClientHello message including a Supported Point Formats Extension
   appends this extension (along with others) to its ServerHello
   message, enumerating the point formats it can parse.  The Supported
   Point Formats Extension, when used, MUST contain the value 0
   (uncompressed) as one of the items in the list of point formats.

</p><p class="rfcparagraph">   Actions of the receiver:

</p><p class="rfcparagraph">   A client that receives a ServerHello message containing a Supported
   Point Formats Extension MUST respect the server's choice of point
   formats during the handshake (cf. Sections 5.6 and 5.7).  If no
   Supported Point Formats Extension is received with the ServerHello,
   this is equivalent to an extension allowing only the uncompressed
   point format.

</p><p class="rfcparagraph">	<a name="section-5.3"><h3>5.3   Server Certificate</h3></a>

   When this message is sent:

</p><p class="rfcparagraph">   This message is sent in all non-anonymous ECC-based key exchange
   algorithms.

</p><p class="rfcparagraph">   Meaning of this message:

</p><p class="rfcparagraph">   This message is used to authentically convey the server's static
   public key to the client.  The following table shows the server
   certificate type appropriate for each key exchange algorithm.  ECC
   public keys MUST be encoded in certificates as described in
   Section 5.9.

</p><p class="rfcparagraph">   NOTE: The server's Certificate message is capable of carrying a chain
   of certificates.  The restrictions mentioned in Table 3 apply only to
   the server's certificate (first in the chain).
          Key Exchange Algorithm  Server Certificate Type
          ----------------------  -----------------------

          ECDH_ECDSA              Certificate MUST contain an
                                  ECDH-capable public key.  It
                                  MUST be signed with ECDSA.

</p><p class="rfcparagraph">          ECDHE_ECDSA             Certificate MUST contain an
                                  ECDSA-capable public key.  It
                                  MUST be signed with ECDSA.

</p><p class="rfcparagraph">          ECDH_RSA                Certificate MUST contain an
                                  ECDH-capable public key.  It
                                  MUST be signed with RSA.

</p><p class="rfcparagraph">          ECDHE_RSA               Certificate MUST contain an
                                  RSA public key authorized for
                                  use in digital signatures.  It
                                  MUST be signed with RSA.

</p><p class="rfcparagraph">                    Table 3: Server Certificate Types

   Structure of this message:

</p><p class="rfcparagraph">   Identical to the TLS Certificate format.

</p><p class="rfcparagraph">   Actions of the sender:

</p><p class="rfcparagraph">   The server constructs an appropriate certificate chain and conveys it
   to the client in the Certificate message.  If the client has used a
   Supported Elliptic Curves Extension, the public key in the server's
   certificate MUST respect the client's choice of elliptic curves; in
   particular, the public key MUST employ a named curve (not the same
   curve as an explicit curve) unless the client has indicated support
   for explicit curves of the appropriate type.  If the client has used
   a Supported Point Formats Extension, both the server's public key
   point and (in the case of an explicit curve) the curve's base point
   MUST respect the client's choice of point formats.  (A server that
   cannot satisfy these requirements MUST NOT choose an ECC cipher suite
   in its ServerHello message.)
   Actions of the receiver:

</p><p class="rfcparagraph">   The client validates the certificate chain, extracts the server's
   public key, and checks that the key type is appropriate for the
   negotiated key exchange algorithm.  (A possible reason for a fatal
   handshake failure is that the client's capabilities for handling
   elliptic curves and point formats are exceeded; cf. Section 5.1.)

	<a name="section-5.4"><h3>5.4   Server Key Exchange</h3></a>

   When this message is sent:

</p><p class="rfcparagraph">   This message is sent when using the ECDHE_ECDSA, ECDHE_RSA, and
   ECDH_anon key exchange algorithms.

</p><p class="rfcparagraph">   Meaning of this message:

</p><p class="rfcparagraph">   This message is used to convey the server's ephemeral ECDH public key
   (and the corresponding elliptic curve domain parameters) to the
   client.

</p><p class="rfcparagraph">   Structure of this message:

</p><p class="rfcparagraph">        enum { explicit_prime (1), explicit_char2 (2),<br>
               named_curve (3), reserved(248..255) } ECCurveType;<br>

</p><p class="rfcparagraph">   explicit_prime:   Indicates the elliptic curve domain parameters are
      conveyed verbosely, and the underlying finite field is a prime
      field.

</p><p class="rfcparagraph">   explicit_char2:   Indicates the elliptic curve domain parameters are
      conveyed verbosely, and the underlying finite field is a
      characteristic-2 field.

</p><p class="rfcparagraph">   named_curve:   Indicates that a named curve is used.  This option
      SHOULD be used when applicable.

</p><p class="rfcparagraph">   Values 248 through 255 are reserved for private use.

</p><p class="rfcparagraph">   The ECCurveType name space is maintained by IANA.  See Section 8 for
   information on how new value assignments are added.

</p><p class="rfcparagraph">        struct {
            opaque a <1..2^8-1>;
            opaque b <1..2^8-1>;
        } ECCurve;
   a, b:   These parameters specify the coefficients of the elliptic
      curve.  Each value contains the byte string representation of a
      field element following the conversion routine in Section 4.3.3 of
      ANSI X9.62 [7].

</p><p class="rfcparagraph">        struct {
            opaque point <1..2^8-1>;
        } ECPoint;

</p><p class="rfcparagraph">   point:   This is the byte string representation of an elliptic curve
      point following the conversion routine in Section 4.3.6 of ANSI
      X9.62 [7].  This byte string may represent an elliptic curve point
      in uncompressed or compressed format; it MUST conform to what the
      client has requested through a Supported Point Formats Extension
      if this extension was used.

</p><p class="rfcparagraph">        enum { ec_basis_trinomial, ec_basis_pentanomial } ECBasisType;

</p><p class="rfcparagraph">   ec_basis_trinomial:   Indicates representation of a characteristic-2
      field using a trinomial basis.

</p><p class="rfcparagraph">   ec_basis_pentanomial:   Indicates representation of a
      characteristic-2 field using a pentanomial basis.

</p><p class="rfcparagraph">        struct {
            ECCurveType    curve_type;
            select (curve_type) {
                case explicit_prime:
                    opaque      prime_p <1..2^8-1>;
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;
                case explicit_char2:
                    uint16      m;
                    ECBasisType basis;
                    select (basis) {
                        case ec_trinomial:
                            opaque  k <1..2^8-1>;
                        case ec_pentanomial:
                            opaque  k1 <1..2^8-1>;
                            opaque  k2 <1..2^8-1>;
                            opaque  k3 <1..2^8-1>;
                    };
                    ECCurve     curve;
                    ECPoint     base;
                    opaque      order <1..2^8-1>;
                    opaque      cofactor <1..2^8-1>;
                case named_curve:
                    NamedCurve namedcurve;
            };
        } ECParameters;

</p><p class="rfcparagraph">   curve_type:   This identifies the type of the elliptic curve domain
      parameters.

</p><p class="rfcparagraph">   prime_p:   This is the odd prime defining the field Fp.

</p><p class="rfcparagraph">   curve:   Specifies the coefficients a and b of the elliptic curve E.

</p><p class="rfcparagraph">   base:   Specifies the base point G on the elliptic curve.

</p><p class="rfcparagraph">   order:   Specifies the order n of the base point.

</p><p class="rfcparagraph">   cofactor:   Specifies the cofactor h = #E(Fq)/n, where #E(Fq)
      represents the number of points on the elliptic curve E defined
      over the field Fq (either Fp or F2^m).

</p><p class="rfcparagraph">   m:   This is the degree of the characteristic-2 field F2^m.

</p><p class="rfcparagraph">   k:   The exponent k for the trinomial basis representation x^m + x^k
      +1.

</p><p class="rfcparagraph">   k1, k2, k3:   The exponents for the pentanomial representation x^m +
      x^k3 + x^k2 + x^k1 + 1 (such that k3 > k2 > k1).

</p><p class="rfcparagraph">   namedcurve:   Specifies a recommended set of elliptic curve domain
      parameters.  All those values of NamedCurve are allowed that refer
      to a specific curve.  Values of NamedCurve that indicate support
      for a class of explicitly defined curves are not allowed here
      (they are only permissible in the ClientHello extension); this
      applies to arbitrary_explicit_prime_curves(0xFF01) and
      arbitrary_explicit_char2_curves(0xFF02).

</p><p class="rfcparagraph">
        struct {
            ECParameters    curve_params;
            ECPoint         public;
        } ServerECDHParams;

</p><p class="rfcparagraph">   curve_params:   Specifies the elliptic curve domain parameters
      associated with the ECDH public key.

</p><p class="rfcparagraph">   public:   The ephemeral ECDH public key.
   The ServerKeyExchange message is extended as follows.

</p><p class="rfcparagraph">        enum { ec_diffie_hellman } KeyExchangeAlgorithm;

</p><p class="rfcparagraph">   ec_diffie_hellman:   Indicates the ServerKeyExchange message contains
      an ECDH public key.

</p><p class="rfcparagraph">        select (KeyExchangeAlgorithm) {
            case ec_diffie_hellman:
                ServerECDHParams    params;
                Signature           signed_params;
        } ServerKeyExchange;

</p><p class="rfcparagraph">   params:   Specifies the ECDH public key and associated domain
      parameters.

</p><p class="rfcparagraph">   signed_params:   A hash of the params, with the signature appropriate
      to that hash applied.  The private key corresponding to the
      certified public key in the server's Certificate message is used
      for signing.

</p><p class="rfcparagraph">          enum { ecdsa } SignatureAlgorithm;

</p><p class="rfcparagraph">          select (SignatureAlgorithm) {
              case ecdsa:
                  digitally-signed struct {
                      opaque sha_hash[sha_size];
                  };
          } Signature;

</p><p class="rfcparagraph">
        ServerKeyExchange.signed_params.sha_hash
            SHA(ClientHello.random + ServerHello.random +
                                              ServerKeyExchange.params);

</p><p class="rfcparagraph">   NOTE: SignatureAlgorithm is "rsa" for the ECDHE_RSA key exchange
   algorithm and "anonymous" for ECDH_anon.  These cases are defined in
   TLS [2][3].  SignatureAlgorithm is "ecdsa" for ECDHE_ECDSA.  ECDSA
   signatures are generated and verified as described in Section 5.10,
   and SHA in the above template for sha_hash accordingly may denote a
   hash algorithm other than SHA-1.  As per ANSI X9.62, an ECDSA
   signature consists of a pair of integers, r and s.  The digitally-
   signed element is encoded as an opaque vector <0..2^16-1>, the
   contents of which are the DER encoding [9] corresponding to the
   following ASN.1 notation [8].
           Ecdsa-Sig-Value ::= SEQUENCE {
               r       INTEGER,
               s       INTEGER
           }

   Actions of the sender:

</p><p class="rfcparagraph">   The server selects elliptic curve domain parameters and an ephemeral
   ECDH public key corresponding to these parameters according to the
   ECKAS-DH1 scheme from IEEE 1363 [6].  It conveys this information to
   the client in the ServerKeyExchange message using the format defined
   above.

</p><p class="rfcparagraph">   Actions of the receiver:

</p><p class="rfcparagraph">   The client verifies the signature (when present) and retrieves the
   server's elliptic curve domain parameters and ephemeral ECDH public
   key from the ServerKeyExchange message.  (A possible reason for a
   fatal handshake failure is that the client's capabilities for
   handling elliptic curves and point formats are exceeded;
   cf. Section 5.1.)

	<a name="section-5.5"><h3>5.5   Certificate Request</h3></a>

   When this message is sent:

</p><p class="rfcparagraph">   This message is sent when requesting client authentication.

</p><p class="rfcparagraph">   Meaning of this message:

</p><p class="rfcparagraph">   The server uses this message to suggest acceptable client
   authentication methods.

</p><p class="rfcparagraph">   Structure of this message:

</p><p class="rfcparagraph">   The TLS CertificateRequest message is extended as follows.

</p><p class="rfcparagraph">        enum {
            ecdsa_sign(64), rsa_fixed_ecdh(65),<br>
            ecdsa_fixed_ecdh(66), (255)<br>
        } ClientCertificateType;

</p><p class="rfcparagraph">   ecdsa_sign, etc.  Indicates that the server would like to use the
      corresponding client authentication method specified in Section 3.
   Actions of the sender:

</p><p class="rfcparagraph">   The server decides which client authentication methods it would like
   to use, and conveys this information to the client using the format
   defined above.

</p><p class="rfcparagraph">   Actions of the receiver:

</p><p class="rfcparagraph">   The client determines whether it has a suitable certificate for use
   with any of the requested methods and whether to proceed with client
   authentication.

</p><p class="rfcparagraph">	<a name="section-5.6"><h3>5.6   Client Certificate</h3></a>

   When this message is sent:

</p><p class="rfcparagraph">   This message is sent in response to a CertificateRequest when a
   client has a suitable certificate and has decided to proceed with
   client authentication.  (Note that if the server has used a Supported
   Point Formats Extension, a certificate can only be considered
   suitable for use with the ECDSA_sign, RSA_fixed_ECDH, and
   ECDSA_fixed_ECDH authentication methods if the public key point
   specified in it respects the server's choice of point formats.  If no
   Supported Point Formats Extension has been used, a certificate can
   only be considered suitable for use with these authentication methods
   if the point is represented in uncompressed point format.)

   Meaning of this message:

</p><p class="rfcparagraph">   This message is used to authentically convey the client's static
   public key to the server.  The following table summarizes what client
   certificate types are appropriate for the ECC-based client
   authentication mechanisms described in Section 3.  ECC public keys
   must be encoded in certificates as described in Section 5.9.

</p><p class="rfcparagraph">   NOTE: The client's Certificate message is capable of carrying a chain
   of certificates.  The restrictions mentioned in Table 4 apply only to
   the client's certificate (first in the chain).
          Client
          Authentication Method   Client Certificate Type
          ---------------------   -----------------------

          ECDSA_sign              Certificate MUST contain an
                                  ECDSA-capable public key and
                                  be signed with ECDSA.

</p><p class="rfcparagraph">          ECDSA_fixed_ECDH        Certificate MUST contain an
                                  ECDH-capable public key on the
                                  same elliptic curve as the server's
                                  long-term ECDH key.  This certificate
                                  MUST be signed with ECDSA.

</p><p class="rfcparagraph">          RSA_fixed_ECDH          Certificate MUST contain an
                                  ECDH-capable public key on the
                                  same elliptic curve as the server's
                                  long-term ECDH key.  This certificate
                                  MUST be signed with RSA.

</p><p class="rfcparagraph">                     Table 4: Client Certificate Types

   Structure of this message:

</p><p class="rfcparagraph">   Identical to the TLS client Certificate format.

</p><p class="rfcparagraph">   Actions of the sender:

</p><p class="rfcparagraph">   The client constructs an appropriate certificate chain, and conveys
   it to the server in the Certificate message.

</p><p class="rfcparagraph">   Actions of the receiver:

</p><p class="rfcparagraph">   The TLS server validates the certificate chain, extracts the client's
   public key, and checks that the key type is appropriate for the
   client authentication method.

</p><p class="rfcparagraph">	<a name="section-5.7"><h3>5.7   Client Key Exchange</h3></a>

   When this message is sent:

</p><p class="rfcparagraph">   This message is sent in all key exchange algorithms.  If client
   authentication with ECDSA_fixed_ECDH or RSA_fixed_ECDH is used, this
   message is empty.  Otherwise, it contains the client's ephemeral ECDH
   public key.
   Meaning of the message:

</p><p class="rfcparagraph">   This message is used to convey ephemeral data relating to the key
   exchange belonging to the client (such as its ephemeral ECDH public
   key).

</p><p class="rfcparagraph">   Structure of this message:

</p><p class="rfcparagraph">   The TLS ClientKeyExchange message is extended as follows.

</p><p class="rfcparagraph">        enum { implicit, explicit } PublicValueEncoding;

</p><p class="rfcparagraph">   implicit, explicit:   For ECC cipher suites, this indicates whether
      the client's ECDH public key is in the client's certificate
      ("implicit") or is provided, as an ephemeral ECDH public key, in
      the ClientKeyExchange message ("explicit").  (This is "explicit"
      in ECC cipher suites except when the client uses the
      ECDSA_fixed_ECDH or RSA_fixed_ECDH client authentication
      mechanism.)

        struct {
            select (PublicValueEncoding) {
                case implicit: struct { };
                case explicit: ECPoint ecdh_Yc;
            } ecdh_public;
        } ClientECDiffieHellmanPublic;

</p><p class="rfcparagraph">   ecdh_Yc:   Contains the client's ephemeral ECDH public key as a byte
      string ECPoint.point, which may represent an elliptic curve point
      in uncompressed or compressed format.  Here, the format MUST
      conform to what the server has requested through a Supported Point
      Formats Extension if this extension was used, and MUST be
      uncompressed if this extension was not used.

</p><p class="rfcparagraph">        struct {
            select (KeyExchangeAlgorithm) {
                case ec_diffie_hellman: ClientECDiffieHellmanPublic;
            } exchange_keys;
        } ClientKeyExchange;

</p><p class="rfcparagraph">   Actions of the sender:

</p><p class="rfcparagraph">   The client selects an ephemeral ECDH public key corresponding to the
   parameters it received from the server according to the ECKAS-DH1
   scheme from IEEE 1363 [6].  It conveys this information to the client
   in the ClientKeyExchange message using the format defined above.
   Actions of the receiver:

</p><p class="rfcparagraph">   The server retrieves the client's ephemeral ECDH public key from the
   ClientKeyExchange message and checks that it is on the same elliptic
   curve as the server's ECDH key.

</p><p class="rfcparagraph">	<a name="section-5.8"><h3>5.8   Certificate Verify</h3></a>

   When this message is sent:

</p><p class="rfcparagraph">   This message is sent when the client sends a client certificate
   containing a public key usable for digital signatures, e.g., when the
   client is authenticated using the ECDSA_sign mechanism.

</p><p class="rfcparagraph">   Meaning of the message:

</p><p class="rfcparagraph">   This message contains a signature that proves possession of the
   private key corresponding to the public key in the client's
   Certificate message.

</p><p class="rfcparagraph">   Structure of this message:

</p><p class="rfcparagraph">   The TLS CertificateVerify message and the underlying Signature type
   are defined in [2] and [3], and the latter is extended here in
   Section 5.4.  For the ecdsa case, the signature field in the
   CertificateVerify message contains an ECDSA signature computed over
   handshake messages exchanged so far, exactly similar to
   CertificateVerify with other signing algorithms in [2] and [3]:

</p><p class="rfcparagraph">        CertificateVerify.signature.sha_hash
            SHA(handshake_messages);

</p><p class="rfcparagraph">   ECDSA signatures are computed as described in Section 5.10, and SHA
   in the above template for sha_hash accordingly may denote a hash
   algorithm other than SHA-1.  As per ANSI X9.62, an ECDSA signature
   consists of a pair of integers, r and s.  The digitally-signed
   element is encoded as an opaque vector <0..2^16-1>, the contents of
   which are the DER encoding [9] corresponding to the following ASN.1
   notation [8].

</p><p class="rfcparagraph">        Ecdsa-Sig-Value ::= SEQUENCE {
            r       INTEGER,
            s       INTEGER
        }
   Actions of the sender:

</p><p class="rfcparagraph">   The client computes its signature over all handshake messages sent or
   received starting at client hello and up to but not including this
   message.  It uses the private key corresponding to its certified
   public key to compute the signature, which is conveyed in the format
   defined above.

</p><p class="rfcparagraph">   Actions of the receiver:

</p><p class="rfcparagraph">   The server extracts the client's signature from the CertificateVerify
   message, and verifies the signature using the public key it received
   in the client's Certificate message.

</p><p class="rfcparagraph">	<a name="section-5.9"><h3>5.9   Elliptic Curve Certificates</h3></a>

   X.509 certificates containing ECC public keys or signed using ECDSA
   MUST comply with [14] or another RFC that replaces or extends it.
   Clients SHOULD use the elliptic curve domain parameters recommended
   in ANSI X9.62 [7], FIPS 186-2 [11], and SEC 2 [13].

</p><p class="rfcparagraph">	<a name="section-5.10"><h3>5.10   ECDH, ECDSA, and RSA Computations</h3></a>

   All ECDH calculations (including parameter and key generation as well
   as the shared secret calculation) are performed according to [6]
   using the ECKAS-DH1 scheme with the identity map as key derivation
   function (KDF), so that the premaster secret is the x-coordinate of
   the ECDH shared secret elliptic curve point represented as an octet
   string.  Note that this octet string (Z in IEEE 1363 terminology) as
   output by FE2OSP, the Field Element to Octet String Conversion
   Primitive, has constant length for any given field; leading zeros
   found in this octet string MUST NOT be truncated.

</p><p class="rfcparagraph">   (Note that this use of the identity KDF is a technicality.  The
   complete picture is that ECDH is employed with a non-trivial KDF
   because TLS does not directly use the premaster secret for anything
   other than for computing the master secret.  As of TLS 1.0 [2] and
   1.1 [3], this means that the MD5- and SHA-1-based TLS PRF serves as a
   KDF; it is conceivable that future TLS versions or new TLS extensions
   introduced in the future may vary this computation.)

   All ECDSA computations MUST be performed according to ANSI X9.62 [7]
   or its successors.  Data to be signed/verified is hashed, and the
   result run directly through the ECDSA algorithm with no additional
   hashing.  The default hash function is SHA-1 [10], and sha_size (see
   Sections 5.4 and 5.8) is 20.  However, an alternative hash function,
   such as one of the new SHA hash functions specified in FIPS 180-2
   [10], may be used instead if the certificate containing the EC public
   key explicitly requires use of another hash function.  (The mechanism
   for specifying the required hash function has not been standardized,
   but this provision anticipates such standardization and obviates the
   need to update this document in response.  Future PKIX RFCs may
   choose, for example, to specify the hash function to be used with a
   public key in the parameters field of subjectPublicKeyInfo.)

   All RSA signatures must be generated and verified according to PKCS#1
   [12] block type 1.

</p><p class="rfcparagraph">	<a name="section-6"><h2>6.   Cipher Suites</h2></a>

   The table below defines new ECC cipher suites that use the key
   exchange algorithms specified in Section 2.

</p><p class="rfcparagraph">     CipherSuite TLS_ECDH_ECDSA_WITH_NULL_SHA           = { 0xC0, 0x01 }
     CipherSuite TLS_ECDH_ECDSA_WITH_RC4_128_SHA        = { 0xC0, 0x02 }
     CipherSuite TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA   = { 0xC0, 0x03 }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA    = { 0xC0, 0x04 }
     CipherSuite TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA    = { 0xC0, 0x05 }

     CipherSuite TLS_ECDHE_ECDSA_WITH_NULL_SHA          = { 0xC0, 0x06 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_RC4_128_SHA       = { 0xC0, 0x07 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA  = { 0xC0, 0x08 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA   = { 0xC0, 0x09 }
     CipherSuite TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA   = { 0xC0, 0x0A }

     CipherSuite TLS_ECDH_RSA_WITH_NULL_SHA             = { 0xC0, 0x0B }
     CipherSuite TLS_ECDH_RSA_WITH_RC4_128_SHA          = { 0xC0, 0x0C }
     CipherSuite TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA     = { 0xC0, 0x0D }
     CipherSuite TLS_ECDH_RSA_WITH_AES_128_CBC_SHA      = { 0xC0, 0x0E }
     CipherSuite TLS_ECDH_RSA_WITH_AES_256_CBC_SHA      = { 0xC0, 0x0F }

     CipherSuite TLS_ECDHE_RSA_WITH_NULL_SHA            = { 0xC0, 0x10 }
     CipherSuite TLS_ECDHE_RSA_WITH_RC4_128_SHA         = { 0xC0, 0x11 }
     CipherSuite TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x12 }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA     = { 0xC0, 0x13 }
     CipherSuite TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA     = { 0xC0, 0x14 }

     CipherSuite TLS_ECDH_anon_WITH_NULL_SHA            = { 0xC0, 0x15 }
     CipherSuite TLS_ECDH_anon_WITH_RC4_128_SHA         = { 0xC0, 0x16 }
     CipherSuite TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA    = { 0xC0, 0x17 }
     CipherSuite TLS_ECDH_anon_WITH_AES_128_CBC_SHA     = { 0xC0, 0x18 }
     CipherSuite TLS_ECDH_anon_WITH_AES_256_CBC_SHA     = { 0xC0, 0x19 }

                        Table 5: TLS ECC cipher suites
   The key exchange method, cipher, and hash algorithm for each of these
   cipher suites are easily determined by examining the name.  Ciphers
   (other than AES ciphers) and hash algorithms are defined in [2] and
   [3].  AES ciphers are defined in [19].

</p><p class="rfcparagraph">   Server implementations SHOULD support all of the following cipher
   suites, and client implementations SHOULD support at least one of
   them: TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA,
   TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA,
   TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, and
   TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA.

</p><p class="rfcparagraph">	<a name="section-7"><h2>7.   Security Considerations</h2></a>

   Security issues are discussed throughout this memo.

</p><p class="rfcparagraph">   For TLS handshakes using ECC cipher suites, the security
   considerations in appendices D.2 and D.3 of [2] and [3] apply
   accordingly.

</p><p class="rfcparagraph">   Security discussions specific to ECC can be found in [6] and [7].
   One important issue that implementers and users must consider is
   elliptic curve selection.  Guidance on selecting an appropriate
   elliptic curve size is given in Table 1.

</p><p class="rfcparagraph">   Beyond elliptic curve size, the main issue is elliptic curve
   structure.  As a general principle, it is more conservative to use
   elliptic curves with as little algebraic structure as possible.
   Thus, random curves are more conservative than special curves such as
   Koblitz curves, and curves over F_p with p random are more
   conservative than curves over F_p with p of a special form (and
   curves over F_p with p random might be considered more conservative
   than curves over F_2^m as there is no choice between multiple fields
   of similar size for characteristic 2).  Note, however, that algebraic
   structure can also lead to implementation efficiencies, and
   implementers and users may, therefore, need to balance conservatism
   against a need for efficiency.  Concrete attacks are known against
   only very few special classes of curves, such as supersingular
   curves, and these classes are excluded from the ECC standards that
   this document references [6], [7].

</p><p class="rfcparagraph">   Another issue is the potential for catastrophic failures when a
   single elliptic curve is widely used.  In this case, an attack on the
   elliptic curve might result in the compromise of a large number of
   keys.  Again, this concern may need to be balanced against efficiency
   and interoperability improvements associated with widely-used curves.
   Substantial additional information on elliptic curve choice can be
   found in [5], [6], [7], and [11].
   Implementers and users must also consider whether they need forward
   secrecy.  Forward secrecy refers to the property that session keys
   are not compromised if the static, certified keys belonging to the
   server and client are compromised.  The ECDHE_ECDSA and ECDHE_RSA key
   exchange algorithms provide forward secrecy protection in the event
   of server key compromise, while ECDH_ECDSA and ECDH_RSA do not.
   Similarly, if the client is providing a static, certified key,
   ECDSA_sign client authentication provides forward secrecy protection
   in the event of client key compromise, while ECDSA_fixed_ECDH and
   RSA_fixed_ECDH do not.  Thus, to obtain complete forward secrecy
   protection, ECDHE_ECDSA or ECDHE_RSA must be used for key exchange,
   with ECDSA_sign used for client authentication if necessary.  Here
   again the security benefits of forward secrecy may need to be
   balanced against the improved efficiency offered by other options.

</p><p class="rfcparagraph">	<a name="section-8"><h2>8.   IANA Considerations</h2></a>

   This document describes three new name spaces for use with the TLS
   protocol:

</p><p class="rfcparagraph">   o  NamedCurve (Section 5.1)

   o  ECPointFormat (Section 5.1)

   o  ECCurveType (Section 5.4)

   For each name space, this document defines the initial value
   assignments and defines a range of 256 values (NamedCurve) or eight
   values (ECPointFormat and ECCurveType) reserved for Private Use.  Any
   additional assignments require IETF Consensus action [16].

</p><p class="rfcparagraph">	<a name="section-9"><h2>9.   Acknowledgements</h2></a>

   The authors wish to thank Bill Anderson and Tim Dierks.
	<a name="section-10"><h2>10.   References</h2></a>

	<a name="section-10.1"><h3>10.1   Normative References</h3></a>

   [1]   Bradner, S., "Key Words for Use in RFCs to Indicate Requirement
         Levels", RFC 2119, March 1997.

</p><p class="rfcparagraph">   [2]   Dierks, T. and C. Allen, "The TLS Protocol Version 1.0",
         RFC 2246, January 1999.

</p><p class="rfcparagraph">   [3]   Dierks, T. and E. Rescorla, "The Transport Layer Security (TLS)
         Protocol Version 1.1", RFC 4346, April 2006.

</p><p class="rfcparagraph">   [4]   Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J., and
         T. Wright, "Transport Layer Security (TLS) Extensions", RFC
         4366, April 2006.

</p><p class="rfcparagraph">   [5]   SECG, "Elliptic Curve Cryptography", SEC 1, 2000,
         <http://www.secg.org/>.

</p><p class="rfcparagraph">   [6]   IEEE, "Standard Specifications for Public Key Cryptography",
         IEEE 1363, 2000.

</p><p class="rfcparagraph">   [7]   ANSI, "Public Key Cryptography For The Financial Services
         Industry: The Elliptic Curve Digital Signature Algorithm
         (ECDSA)", ANSI X9.62, 1998.

</p><p class="rfcparagraph">   [8]   International Telecommunication Union, "Information technology
         - Abstract Syntax Notation One (ASN.1): Specification of basic
         notation", ITU-T Recommendation X.680, 2002.

</p><p class="rfcparagraph">   [9]   International Telecommunication Union, "Information technology
         - ASN.1 encoding rules: Specification of Basic Encoding Rules
         (BER), Canonical Encoding Rules (CER) and Distinguished
         Encoding Rules (DER)", ITU-T Recommendation X.690, 2002.

</p><p class="rfcparagraph">   [10]  NIST, "Secure Hash Standard", FIPS 180-2, 2002.

</p><p class="rfcparagraph">   [11]  NIST, "Digital Signature Standard", FIPS 186-2, 2000.

</p><p class="rfcparagraph">   [12]  RSA Laboratories, "PKCS#1: RSA Encryption Standard version
         1.5", PKCS 1, November 1993.

</p><p class="rfcparagraph">   [13]  SECG, "Recommended Elliptic Curve Domain Parameters", SEC 2,
         2000, <http://www.secg.org/>.
   [14]  Polk, T., Housley, R., and L. Bassham, "Algorithms and
         Identifiers for the Internet X.509 Public Key Infrastructure
         Certificate and Certificate Revocation List (CRL) Profile",
         RFC 3279, April 2002.

</p><p class="rfcparagraph">   [15]  Housley, R., Polk, T., Ford, W., and D. Solo, "Internet X.509
         Public Key Infrastructure Certificate and Certificate
         Revocation List (CRL) Profile", RFC 3280, April 2002.

</p><p class="rfcparagraph">   [16]  Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
         Considerations Section in RFCs", RFC 2434, October 1998.

</p><p class="rfcparagraph">	<a name="section-10.2"><h3>10.2   Informative References</h3></a>

   [17]  Harper, G., Menezes, A., and S. Vanstone, "Public-Key
         Cryptosystems with Very Small Key Lengths", Advances in
         Cryptology -- EUROCRYPT '92, LNCS 658, 1993.

</p><p class="rfcparagraph">   [18]  Lenstra, A. and E. Verheul, "Selecting Cryptographic Key
         Sizes", Journal of Cryptology 14 (2001) 255-293,<br>
         <http://www.cryptosavvy.com/>.

</p><p class="rfcparagraph">   [19]  Chown, P., "Advanced Encryption Standard (AES) Ciphersuites for
         Transport Layer Security (TLS)", RFC 3268, June 2002.
Appendix A.  Equivalent Curves (Informative)

   All of the NIST curves [11] and several of the ANSI curves [7] are
   equivalent to curves listed in Section 5.1.1.  In the following
   table, multiple names in one row represent aliases for the same
   curve.

</p><p class="rfcparagraph">             ------------------------------------------
                       Curve names chosen by
                  different standards organizations
             ------------+---------------+-------------
             SECG        |  ANSI X9.62   |  NIST
             ------------+---------------+-------------
             sect163k1   |               |   NIST K-163
             sect163r1   |               |
             sect163r2   |               |   NIST B-163
             sect193r1   |               |
             sect193r2   |               |
             sect233k1   |               |   NIST K-233
             sect233r1   |               |   NIST B-233
             sect239k1   |               |
             sect283k1   |               |   NIST K-283
             sect283r1   |               |   NIST B-283
             sect409k1   |               |   NIST K-409
             sect409r1   |               |   NIST B-409
             sect571k1   |               |   NIST K-571
             sect571r1   |               |   NIST B-571
             secp160k1   |               |
             secp160r1   |               |
             secp160r2   |               |
             secp192k1   |               |
             secp192r1   |  prime192v1   |   NIST P-192
             secp224k1   |               |
             secp224r1   |               |   NIST P-224
             secp256k1   |               |
             secp256r1   |  prime256v1   |   NIST P-256
             secp384r1   |               |   NIST P-384
             secp521r1   |               |   NIST P-521
             ------------+---------------+
</pre>
-------------

      Table 6: Equivalent curves defined by SECG, ANSI, and NIST
Authors' Addresses

   Simon Blake-Wilson
   SafeNet Technologies BV
   Amstelveenseweg 88-90
   1075 XJ, Amsterdam
   NL

   Phone: +31 653 899 836
   EMail: sblakewilson@safenet-inc.com


   Nelson Bolyard
   Sun Microsystems Inc.
   4170 Network Circle
   MS SCA17-201
   Santa Clara, CA  95054
   US

   Phone: +1 408 930 1443
   EMail: nelson@bolyard.com


   Vipul Gupta
   Sun Microsystems Laboratories
   16 Network Circle
   MS UMPK16-160
   Menlo Park, CA  94025
   US

   Phone: +1 650 786 7551
   EMail: vipul.gupta@sun.com


   Chris Hawk
   Corriente Networks LLC
   1563 Solano Ave., #484
   Berkeley, CA  94707
   US

   Phone: +1 510 527 0601
   EMail: chris@corriente.net
   Bodo Moeller
   Ruhr-Uni Bochum
   Horst-Goertz-Institut, Lehrstuhl fuer Kommunikationssicherheit
   IC 4/139
   44780 Bochum
   DE

   Phone: +49 234 32 26795
   EMail: bodo@openssl.org
Full Copyright Statement

   Copyright (C) The Internet Society (2006).<br>

</p><p class="rfcparagraph">   This document is subject to the rights, licenses and restrictions
   contained in BCP 78, and except as set forth therein, the authors
   retain all their rights.

</p><p class="rfcparagraph">   This document and the information contained herein are provided on an
   "AS IS" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET
   ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,
   INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
   INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

</p><p class="rfcparagraph">Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in BCP 78 and BCP 79.

</p><p class="rfcparagraph">   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   http://www.ietf.org/ipr.

</p><p class="rfcparagraph">   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.

</p><p class="rfcparagraph">Acknowledgement

   Funding for the RFC Editor function is provided by the IETF
   Administrative Support Activity (IASA).

</p>





Blake-Wilson, et al.         Informational                     [Page 35]


      </td>
      <td class=code>
        <div class='highlight'>
            <!--
            <b>Related Stack Overflow questions:</b>
            <ul>
                
            </ul>
            -->
        </div>
      </td>
    </tr>
  </table>
</div>
</body>