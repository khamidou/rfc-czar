<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title></title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1></h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-'>
      <td class=docs>
        <p class="rfcparagraph"><p>Network Working Group                                            W. Zhao<br>Request for Comments: 3528                                H. Schulzrinne<br>Category: Experimental                               Columbia University<br>                                                              E. Guttman<br>                                                        Sun Microsystems<br>                                                              April 2003<br><br></p>
                  <h1>
             Mesh-enhanced Service Location Protocol (mSLP)</h1>
                  <h2>Status of this Memo</h2>

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

</p><p class="rfcparagraph"><h2>Copyright Notice</h2>

   Copyright (C) The Internet Society (2003).  All Rights Reserved.<br>

</p><p class="rfcparagraph"><h2>Abstract</h2>

   This document describes the Mesh-enhanced Service Location Protocol
   (mSLP).  mSLP enhances the Service Location Protocol (SLP) with a
   scope-based fully-meshed peering Directory Agent (DA) architecture.
   Peer DAs exchange new service registrations in shared scopes via
   anti-entropy and direct forwarding.  mSLP improves the reliability
   and consistency of SLP DA services, and simplifies Service Agent (SA)
   registrations in systems with multiple DAs.  mSLP is backward
   compatible with SLPv2 and can be deployed incrementally.

</p><p class="rfcparagraph">Table of Contents
<a href="#section-1" class="">1. Introduction . . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.1" class="indent-1">1.1. Notation Conventions . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.2" class="indent-1">1.2. Terminology  . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.3" class="indent-1">1.3. Compatibility  . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-2" class="">2. Scope-based Fully-meshed Peering DA Architecture . . . . . . </a><br>
<a href="#section-3" class="">3. Peer Relationship Management . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.1" class="indent-1">3.1. Learning about New Peers . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.2" class="indent-1">3.2. Establishing a Peering Connection  . . . . . . . . . . </a><br>
<a href="#section-3.3" class="indent-1">3.3. Exchanging Information about Existing Peers  . . . . . </a><br>
<a href="#section-3.4" class="indent-1">3.4. Maintaining a Peer Relationship  . . . . . . . . . . . </a><br>
<a href="#section-3.5" class="indent-1">3.5. Tearing Down a Peer Relationship . . . . . . . . . . . </a><br>
<a href="#section-4" class="">4. Registration Propagation Control . . . . . . . . . . . . . . </a><br>
<a href="#section-4.1" class="indent-1">4.1. Accept ID and Propagation Order  . . . . . . . . . . . </a><br>
<a href="#section-4.2" class="indent-1">4.2. Version Timestamp and Registration Version Resolution  </a><br>
<a href="#section-4.3" class="indent-1">4.3. Mesh Forwarding Extension  . . . . . . . . . . . . . . </a><br>
<a href="#section-4.4" class="indent-1">4.4. Summary Vector . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.5" class="indent-1">4.5. Service Deregistration . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.6" class="indent-1">4.6. Anti-entropy Request Message . . . . . . . . . . . . . </a><br>
<a href="#section-4.7" class="indent-1">4.7. Anti-entropy . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.8" class="indent-1">4.8. Direct Forwarding  . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.9" class="indent-1">4.9. SrvAck Message . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.10" class="indent-1">4.10. Control Information  . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-5" class="">5. Summary  . . . . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-6" class="">6. Protocol Timing Defaults . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-7" class="">7. IANA Considerations  . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-8" class="">8. Security Considerations  . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-9" class="">9. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-10" class="">10. References . . . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-10.1" class="indent-1">10.1. Normative References . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-10.2" class="indent-1">10.2. Informative References . . . . . . . . . . . . . . . . </a><br>
<a href="#section-11" class="">11. Authors' Addresses . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-12" class="">12. Full Copyright Statement . . . . . . . . . . . . . . . . . . </a><br>

	<a name="section-1"><h2>1.  Introduction</h2></a>

   In the Service Location Protocol (SLPv2 [RFC2608]), Directory Agents
   (DAs) accept service registrations from Service Agents (SAs) and
   answer queries from User Agents (UAs); they enhance the performance
   and scalability of SLPv2.  The use of scopes in SLPv2 further
   improves its scalability.  In general, a DA can serve multiple
   scopes, and a scope can be served by multiple DAs.  When multiple DAs
   are present for a scope, how should they interact with each other?
   This document describes the Mesh-enhanced Service Location Protocol
   (mSLP), addressing this open issue in SLPv2.

</p><p class="rfcparagraph">   mSLP defines a scope-based fully-meshed peering DA architecture: for
   each scope, all DAs serving the scope form a fully-meshed peer
   relationship (similar to IBGP [RFC1771]).  Peer DAs exchange new
   service registrations in shared scopes via anti-entropy [EPID-
   ALGO,UPDA-PROP] and direct forwarding.  mSLP improves the reliability
   and consistency of SLP DA services, and simplifies SA registrations
   in systems with multiple DAs.

</p><p class="rfcparagraph">	<a name="section-1.1"><h3>1.1  Notation Conventions</h3></a>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in BCP 14, RFC 2119
   [RFC2119].
	<a name="section-1.2"><h3>1.2  Terminology</h3></a>

   Peer DAs (or Peers)
      DAs that share one or multiple scopes are peers.

</p><p class="rfcparagraph">   Peering Connection
      A persistent connection (e.g., TCP) that provides reliable and
      ordered transfers between two peers.  The closing of a peering
      connection terminates the peer relationship.

</p><p class="rfcparagraph">   Mesh-enhanced DA (MDA)
      An MDA carries the "mesh-enhanced" attribute keyword in its DA
      Advertisement (DAAdvert) message, maintains peering connections to
      all peers, and properly interacts with peers.

</p><p class="rfcparagraph">   Mesh-enhanced SA (MSA)
      An MSA uses the Mesh Forwarding extension (Section 4.3) when it
      registers with MDAs.

</p><p class="rfcparagraph">   Registration Update
      A registration update refers to a Service Registration (SrvReg) or
      Service Deregistration (SrvDeReg) message.

</p><p class="rfcparagraph">   Registration State
      A registration state refers to an entry in the registration
      database.

</p><p class="rfcparagraph">   Accept DA
      When a DA accepts a registration update from an SA, the DA is the
      accept DA for the update.

</p><p class="rfcparagraph">   Accept Timestamp
      The arrival timestamp of a registration update at its accept DA is
      the accept timestamp of the update.  All accept timestamps
      assigned by the same DA MUST be monotonically increasing.

</p><p class="rfcparagraph">   Version Timestamp
      When an MSA sends a registration update to an MDA, the MSA assigns
      a version timestamp to the update.  All version timestamps
      assigned by the same MSA MUST be monotonically increasing.

</p><p class="rfcparagraph">	<a name="section-1.3"><h3>1.3  Compatibility</h3></a>

   mSLP is designed as a lightweight enhancement to SLPv2.  It is
   backward compatible with SLPv2.  mSLP defines two enhanced entities:
   MDAs and MSAs.  They can be deployed incrementally.  An enhanced
   entity supports extended operations without affecting its original
   functionality as defined in RFC 2608 [RFC2608].  For simplicity and
   compatibility, an enhanced entity works as a non-enhanced entity to
   interact with non-enhanced entities.  Table 1 summarizes all
   interactions involving an MDA or MSA.

</p><p class="rfcparagraph">            Interaction       Equivalent To     Defined In
            ----------------------------------------------
            MDA <--> MDA                           mSLP
            MDA <--> MSA                           mSLP
            MDA <--> DA        DA <--> DA        RFC 2608
            MDA <--> SA        DA <--> SA        RFC 2608
            MDA <--> UA        DA <--> UA        RFC 2608
            MSA <--> DA        SA <--> DA        RFC 2608
            MSA <--> UA        SA <--> UA        RFC 2608

             Table 1. Interactions involving an MDA or MSA

	<a name="section-2"><h2>2.  Scope-based Fully-meshed Peering DA Architecture</h2></a>

                                 (x,y)<pre>
          +--------------------------------------------------+
          |                  +------------+                  |
          |                  |  MDA4 (z)  |                  |
          |                  +------------+                  |
          |                        | (z)                     |
   +------------+     (y)    +------------+     (y)    +------------+
   | MDA1 (x,y) | ---------- | MDA3 (y,z) | ---------- | MDA2 (x,y) |
   +------------+            +------------+            +------------+

      Figure 1. A scope-based fully-meshed peering DA architecture

   mSLP employs a scope-based fully-meshed peering DA architecture.  For
   each scope, all MDAs that serve the scope form a fully-meshed peer
   relationship.  Figure 1 shows an example for four MDAs and three
   scopes (x, y, and z).  Note that a single peering connection is
   needed between two peers for exchanging all service registrations in
   their shared scopes.

</p><p class="rfcparagraph">   This architecture enhances SLP DA services.  First, it improves the
   consistency among peer DAs by automatically reconciling inconsistent
   states among them.  Second, it enables newly booted and rebooted MDAs
   to catch up on all new registrations at once from their peers, purely
   through DA interaction, without involving SAs.

</p><p class="rfcparagraph">   This architecture also simplifies SA registrations.  In SLPv2, an SA
   needs to discover and register with all existing DAs in its scopes,
   and re-register when new DAs are discovered or old DAs are found to
   have rebooted.  In mSLP, for all MDAs, an MSA only needs to discover
   and register with a sufficient number of them, such that the union of
   their scopes covers its scopes; the registrations will then be
   propagated automatically to other MDAs in the registration scopes.
   For example, in Figure 2, MSA1 only needs to discover and register
   with MDA2, or with both MDA1 and MDA3.

</p><p class="rfcparagraph">                 (option2)  +------------+  (option2)
         +----------------- | MSA1 (x,y) | -----------------+
         |                  +------------+                  |
         |                        | (option1)               |
         V                        V                         V
   +----------+             +------------+             +----------+
   | MDA1 (x) | ----------- | MDA2 (x,y) | ----------- | MDA3 (y) |
   +----------+             +------------+             +----------+

            Figure 2. Options for registering with MDAs

   Furthermore, this architecture provides scaling advantages.  Consider
   a scope that has N SAs and M DAs, and assume N > M >= 2.  Although
   mSLP and SLPv2 need the same number of SLP messages to distribute
   registrations from N SAs to M DAs, mSLP can reduce the number of
   agents needed for taking care of registration distribution, and
   reduce the number of TCP connections needed if each SA uses TCP for
   its registrations.  More specifically, the agents that need to take
   care of registration distribution are all N SAs in SLPv2, but only M
   DAs in mSLP.  Also, the number of needed TCP connections is N*M in
   SLPv2 as each SA has to connect with each DA and register, but only
   N+M*(M-1)/2 in mSLP as each SA only needs to connect to one
   contacting DA of a full mesh of M node and register, then
   registrations are propagated through the DA mesh.  For N=100 and
   M=10, SLPv2 needs 1000 TCP connections, but mSLP only needs 145 such
   connections.

</p><p class="rfcparagraph">   Note that as mSLP employs full-mesh topology, which is mainly for
   simplicity and reliability, it cannot scale to a large number of MDAs
   in a single mesh.  In general, mSLP can be applied if the number of
   MDAs in a mesh is on the order of tens or below.  One way to avoid
   having a large number of MDAs in a mesh is to split the scope into
   several finer scopes.  For example, if we have N MDAs for scope "x",
   and N is too large, then we can split "x" into two finer scopes:
   "x-1" and "x-2", with N1 MDAs for "x-1" only, N2 MDAs for "x-2" only,
   N3 MDAs for both "x-1" and "x-2", and N1+N2+N3=N.  Thus, instead of
   having a large full mesh of size N, we now have two smaller full
   meshes of size N1+N3 and N2+N3, respectively.  Accordingly, a service
   registration that previously targets for scope "x", now needs to be
   registered under both "x-1" and "x-2".
	<a name="section-3"><h2>3.  Peer Relationship Management</h2></a>

	<a name="section-3.1"><h3>3.1  Learning about New Peers</h3></a>

   An MDA can learn about new peers via static configuration, DHCP
   [RFC2610], and DAAdvert multicast and unicast.  In any case, an MDA
   MUST get a peer's DAAdvert before establishing a peer relationship to
   the peer.

</p><p class="rfcparagraph">	<a name="section-3.2"><h3>3.2  Establishing a Peering Connection</h3></a>

   After getting a new peer's DAAdvert, an MDA establishes a peering
   connection (if such a connection does not exist yet) to the peer, and
   sends its DAAdvert via the connection (Figure 3).  An MDA can
   identify a peering connection initiated by a peer by receiving the
   peer's DAAdvert from the connection.  Normally, a single peering
   connection is set up between two peers, but there is a small
   possibility that a pair of peering connections might be created
   between two peers if they try to initiate a connection to each other
   at almost the same time.  Thus, when an MDA identifies a new peering
   connection initiated by a peer, it SHOULD check whether it has
   initiated another peering connection to the peer.  If this is the
   case, and it has a lower-numbered IP address than the peer, then the
   MDA SHOULD terminate the connection it has initiated.

</p><p class="rfcparagraph">      +------+    (1) MDA2's DAAdvert |                 +------+<br>
      |      | <----------------------+                 |      |
      | MDA1 |    (2) Create a Peering Connection       | MDA2 |<br>
      |      | ---------------------------------------> |      |
      +------+    (3) MDA1's DAAdvert                   +------+<br>

             Figure 3. Establishing a peering connection

	<a name="section-3.3"><h3>3.3  Exchanging Information about Existing Peers</h3></a>

   After establishing a peering connection, two peers (say, MDA1 and
   MDA2) exchange information about their existing peers by forwarding
   peers' DAAdverts via the peering connection (Figure 4).  MDA1 will
   forward the DAAdvert of a peer (say, MDA3) to MDA2 if:

</p><p class="rfcparagraph">      (1) MDA3 shares scopes with MDA2, and<br>
      (2) MDA3 is an active peer of MDA1 (i.e., there is a peering<br>
          connection between MDA3 and MDA1) or an accept DA for
          registrations currently maintained by MDA1 (i.e., MDA1
          has registrations originally accepted by MDA3).
   MDA2 operates similarly.  Note that all DAAdverts can be sent as one
   TCP stream for efficiency.  Exchanging information about existing
   peers enables an MDA to learn about new peers incrementally.

</p><p class="rfcparagraph">      +------+      DAAdverts of MDA1's existing peers     +------+
      |      | ------------------------------------------> |      |
      | MDA1 |             (Peering Connection)            | MDA2 |
      |      | <------------------------------------------ |      |
      +------+      DAAdverts of MDA2's existing peers     +------+

          Figure 4. Exchanging information about existing peers

	<a name="section-3.4"><h3>3.4  Maintaining a Peer Relationship</h3></a>

      +------+              MDA1's DAAdvert             +------+
      |      | ---------------------------------------> |      |
      | MDA1 |           (Peering Connection)           | MDA2 |
      |      | <--------------------------------------- |      |
      +------+              MDA2's DAAdvert             +------+

            Figure 5. Maintaining a peer relationship

   To detect failures (network partitions and peer crashes), mSLP uses a
   heart-beat mechanism.  An MDA sends its DAAdvert to peers (Figure 5)
   every CONFIG_DA_KEEPALIVE seconds.  The timeout value for this
   message is CONFIG_DA_TIMEOUT seconds (Section 6).

</p><p class="rfcparagraph">	<a name="section-3.5"><h3>3.5  Tearing Down a Peer Relationship</h3></a>

   An MDA SHOULD tear down a peer relationship when it finds that the
   peer has closed the peering connection, when it receives a DAAdvert
   multicast from the peer with a DA stateless boot timestamp set to 0
   (meaning that the peer is going to shutdown), or when it has not
   received the peer's DAAdvert for more than CONFIG_DA_TIMEOUT seconds.

</p><p class="rfcparagraph">	<a name="section-4"><h2>4.  Registration Propagation Control</h2></a>

	<a name="section-4.1"><h3>4.1  Accept ID and Propagation Order</h3></a>

   When an MDA accepts a registration update from an MSA, the MDA
   assigns a unique accept ID to the update.  An accept ID has two
   components: an accept DA URL and an accept timestamp.  The accept
   timestamp is a 64-bit integer representing elapsed microseconds since
   00:00 Coordinated Universal Time (UTC), January 1, 1900.  Figure 6
   shows the format for an accept ID entry.  A registration state has
   the same accept ID as that of the latest update applied to it.
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Accept Timestamp                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                        Accept Timestamp, cont'd.              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Length of Accept DA URL    |         Accept DA URL         \
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 6. Accept ID entry

   An MDA MUST propagate registrations in the increasing order of their
   accept IDs, i.e., registrations having the same accept DA MUST be
   propagated in the increasing order of their accept timestamps.  Note
   that registrations having different accept DAs MAY be propagated in
   any order.

</p><p class="rfcparagraph">	<a name="section-4.2"><h3>4.2  Version Timestamp and Registration Version Resolution</h3></a>

   When registrations are propagated among MDAs, their arrival
   timestamps at MDAs cannot be used for version resolution.  For
   example, assume that MSA1 sends a registration (R1) to MDA1 first,
   and a new version of the same registration (R2) to MDA2 later.  When
   R1 and R2 are propagated, the arrival timestamp of R1 at MDA2 is
   later than that of R2, but R1 SHOULD NOT overwrite R2 at MDA2 as R2
   is a newer version.

</p><p class="rfcparagraph">   mSLP resolves registration versions using version timestamps.  When
   an MSA sends a registration update to an MDA, the MSA assigns a
   version timestamp to the update.  The version timestamp is a 64-bit
   integer representing elapsed microseconds since 00:00 UTC, January 1,
   1900.  mSLP assumes that each registration is updated only by one SA,
   thus an MDA does not need to compare version timestamps from
   different MSAs.  An MDA installs a registration update if the update
   has a newer version timestamp (from an MSA), or the update does not
   have the Mesh Forwarding extension (from a non-MSA).

</p><p class="rfcparagraph">	<a name="section-4.3"><h3>4.3  Mesh Forwarding Extension</h3></a>

   The Mesh Forwarding (MeshFwd) extension carries a version timestamp
   and an accept ID entry.  Figure 7 shows its format and two defined
   Forwarding IDs (Fwd-IDs).

</p><p class="rfcparagraph">   The MeshFwd extension is used with a Srv(De)Reg message, but it can
   only be used with a fresh SrvReg, or a complete SrvDeReg.
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | MeshFwd Extension ID = 0x0006 |  Next Extension Offset (NEO)  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      | NEO, cont'd.  |     Fwd-ID    |       Version Timestamp       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                  Version Timestamp, cont'd.                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Version Timestamp, cont'd.  |       Accept ID Entry         \
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Fwd-ID         Abbreviation
                        1              RqstFwd
                        2              Fwded

                 Figure 7. MeshFwd extension and its Fwd-IDs

   An MSA uses the RqstFwd MeshFwd extension (Fwd-ID = RqstFwd, accept
   timestamp = 0) in a Srv(De)Reg to explicitly request an MDA (the
   accept DA) to forward the message.

</p><p class="rfcparagraph">   An MDA uses the Fwded MeshFwd extension (Fwd-ID = Fwded, accept
   timestamp != 0) in each Srv(De)Reg sent from it to another MDA,
   either forwarding a Srv(De)Reg received from an MSA (if the message
   has the RqstFwd MeshFwd extension), or propagating a registration
   state in its database.

</p><p class="rfcparagraph">	<a name="section-4.4"><h3>4.4  Summary Vector</h3></a>

   An MDA uses a summary vector to represent its received Srv(De)Reg(s)
   that have a MeshFwd extension.  This summary vector records the
   latest accept timestamp for each accept DA that appears in the
   MeshFwd extension.  For example, consider n MDAs for a scope, if MDAi
   has a summary vector as ((MDA1, T1), (MDA2, T2), ..., (MDAn, Tn)),
   then MDAi has received all registrations originally accepted by MDAj
   up to timestamp Tj, where 1<=i,j<=n.

</p><p class="rfcparagraph">   An MDA updates its summary vector when it receives a Srv(De)Reg that
   has a MeshFwd extension.  The MDA adds a new accept ID to its summary
   vector if the Srv(De)Reg has a new accept DA; the MDA updates the
   accept timestamp of an existing accept ID in its summary vector if
   the Srv(De)Reg has an existing accept DA.
	<a name="section-4.5"><h3>4.5  Service Deregistration</h3></a>

   When an MDA receives a SrvDeReg that has a MeshFwd extension, it
   SHOULD retain the corresponding registration in the database, and
   mark it as deleted.  This way, the registration will not appear in
   any query reply, and an earlier SrvReg will not mistakenly cause the
   registration to reappear in the database.  A registration state will
   be purged from the database when it expires.

</p><p class="rfcparagraph">	<a name="section-4.6"><h3>4.6  Anti-entropy Request Message</h3></a>

   The Anti-entropy Request (AntiEtrpRqst) message carries an anti-
   entropy type ID and a list of accept ID entries.  Figure 8 shows its
   format and two defined anti-entropy type IDs.

</p><p class="rfcparagraph">       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |    Service Location Header (AntiEtrpRqst Function-ID =  12)   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |      Anti-Entropy Type ID     |  Number of Accept ID Entries  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Accept ID Entry 1         . . .         Accept ID Entry k   \
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                    Anti-Entropy Type       Type ID
                       selective               1
                       complete                2

          Figure 8. AntiEtrpRqst message and anti-entropy types

   The AntiEtrpRqst message is used by an MDA to request new
   registration states from a peer.  The anti-entropy type is either
   selective or complete.  If the anti-entropy type is selective, only
   registration states that have an accept ID greater than any specified
   accept ID in the message are requested.  If the anti-entropy type is
   complete, all registration states that have an accept ID greater than
   any specified accept ID in the message or have an accept DA not
   specified in the message are requested.

</p><p class="rfcparagraph">   For example, consider three MDAs (MDA1, MDA2, and MDA3) for a scope.
   MDA2 has registration states originally accepted by MDA1, MDA2, and
   MDA3.  If MDA1 sends a selective AntiEtrpRqst to MDA2 using an accept
   ID list as ((MDA2, T2)), then MDA1 only requests registration states
   that are originally accepted by MDA2, and have an accept timestamp
   greater than T2.  If MDA1 sends a complete AntiEtrpRqst to MDA2 using
   an accept ID list as ((MDA2, T2)), then MDA1 requests all
   registration states originally accepted by MDA1 and MDA3, plus those
   originally accepted by MDA2 and having an accept timestamp greater
   than T2.

</p><p class="rfcparagraph">	<a name="section-4.7"><h3>4.7  Anti-entropy</h3></a>

   Anti-entropy is used for exchanging initial registration states when
   two peers recognize each other for the first time, and for updating
   new registration states after failures.

</p><p class="rfcparagraph">   When an MDA receives an AntiEtrpRqst from a peer, it sends the
   requested new registration states in the increasing order of their
   accept IDs.  At last a Service Acknowledgment (SrvAck) message is
   sent to indicate that the processing of a corresponding AntiEtrpRqst
   has been completed (Figure 9).  A new registration state is sent as a
   fresh SrvReg with its remaining lifetime.  A newly deregistered state
   is propagated as a SrvDeReg.  Note that multiple Srv(De)Reg(s) can be
   sent as one TCP stream for efficiency.

</p><p class="rfcparagraph">      +------+                AntiEtrpRqst                  +------+
      |      | -------------------------------------------> |      |
      | MDA1 |            (Peering Connection)              | MDA2 |
      |      | <------------------------------------------- |      |
      +------+     New States via Srv(De)Reg(s) + SrvAck    +------+

      Figure 9. Anti-entropy via AntiEtrpRqst, Srv(De)Reg(s) and SrvAck

	<a name="section-4.8"><h3>4.8  Direct Forwarding</h3></a>

+------+   RqstFwd Srv(De)Reg   +------+   Fwded Srv(De)Reg    +------+
|      | ---------------------> |      | --------------------> |      |
| MSA1 |                        | MDA1 |                       | MDA2 |
|      | <--------------------- |      |                       |      |
+------+         SrvAck         +------+                       +------+
</pre>


            Figure 10. Direct forwarding of a Srv(De)Reg

   After sending all new registration states accepted by itself to a
   peer (via anti-entropy), an MDA directly forwards newly received
   registration updates from MSAs to the peer until a failure occurs.

</p><p class="rfcparagraph">   In Figure 10, when a Srv(De)Reg is directly forwarded from MDA1 to
   MDA2, its Fwd-ID is set to Fwded, and its accept timestamp is set to
   its arrival timestamp at MDA1.  Note that a direct forwarding is
   performed asynchronously: MDA1 can send a SrvAck to MSA1 before it
   forwards the Srv(De)Reg to MDA2.  Also note that the direct
   forwarding of a Srv(De)Reg goes only one-hop from its accept DA (say,
   MDA1) to all MDA1's peers that are in the registration scopes.
	<a name="section-4.9"><h3>4.9  SrvAck Message</h3></a>

   According to [RFC2608], a DA MUST reply with a SrvAck to a Srv(De)Reg
   when the message is received from an SA.  However, an MDA SHOULD NOT
   reply with a SrvAck to a Srv(De)Reg if the message is received from a
   peer.  This is for efficiency because peers exchange Srv(De)Reg
   messages via reliable peering connections.  Note that an MDA MUST
   reply with a SrvAck to an AntiEtrpRqst.

</p><p class="rfcparagraph">	<a name="section-4.10"><h3>4.10  Control Information</h3></a>

   For each registration entry, an MDA maintains the following control
   information: an accept ID (for registration propagation), a version
   timestamp (for registration version resolution - rejecting previous
   updates), and a deletion flag (deregistered or not).

</p><p class="rfcparagraph">   For all registration entries, an MDA maintains a summary vector to
   reflect its received registrations so far.

</p><p class="rfcparagraph">	<a name="section-5"><h2>5.  Summary</h2></a>

   mSLP extends SLPv2 with three new definitions: a new attribute -
   "mesh-enhanced" for DAAdvert, a new message extension - MeshFwd, and
   a new message type - AntiEtrpRqst.

</p><p class="rfcparagraph">   A UA MAY prefer an MDA to a non-MDA since an MDA is more likely to
   reliably contain the complete set of current service registrations
   for the UA's scopes.

</p><p class="rfcparagraph">   A non-MSA needs to discover and register with all DAs in its scopes.
   It does not use the MeshFwd extension.

</p><p class="rfcparagraph">   A non-MDA accepts Srv(De)Reg(s) from SAs.  It does not forward them.

</p><p class="rfcparagraph">   For all MDAs, an MSA only needs to discover and register with
   sufficient number of them, such that they cover its scopes.  It uses
   the MeshFwd extension when it registers with MDAs.

</p><p class="rfcparagraph">   An MDA carries the "mesh-enhanced" attribute keyword in its DAAdvert.
   It maintains a peer relationship to each peer.  It accepts
   registrations from SAs and peers, propagates registrations via anti-
   entropy and direct forwarding to peers.
	<a name="section-6"><h2>6.  Protocol Timing Defaults</h2></a>

     Interval Name          Default Value      Defined in
   -------------------      -------------      -----------
   CONFIG_DA_KEEPALIVE       200 seconds       Section 3.4
   CONFIG_DA_TIMEOUT         300 seconds       Section 3.4

	<a name="section-7"><h2>7.  IANA Considerations</h2></a>

   The Mesh Forwarding (MeshFwd) extension ID, 0x0006, described in
   Section 4.3, has been assigned by IANA out of the SLP extension space
   (RFC 2608, Section 9.1) reserved for "optional to implement"
   extensions (i.e., the 0x0000-0x3FFF range).

</p><p class="rfcparagraph">   The function-ID of the Anti-entropy Request (AntiEtrpRqst) message
   type, 12, described in Section 4.6, has been assigned by IANA (RFC
   2608, Section 15).

</p><p class="rfcparagraph">	<a name="section-8"><h2>8.  Security Considerations</h2></a>

   mSLP uses standard SLPv2 authentication.  First, an MDA SHOULD
   authenticate other MDAs before setting up a peer relationship with
   them so as to prevent any malicious MDA from joining the DA mesh.
   Second, as a successful attack at an MDA may affect all MDAs in the
   DA mesh, an MDA SHOULD authenticate MSAs before accepting and
   forwarding their Srv(De)Reg messages to prevent illegitimate
   modification or elimination of service registrations.  Third, as an
   MSA depends on the MDA with which it registers to forward its
   Srv(De)Reg messages, it SHOULD authenticate the MDA to avoid using a
   malicious MDA.

</p><p class="rfcparagraph">	<a name="section-9"><h2>9.  Acknowledgments</h2></a>

   Thomas Narten, James Kempf, Mike Day, Mikael Pahmp, Ira McDonald,
   Qiaobing Xie and Xingang Guo provided valuable comments for this
   document.

</p><p class="rfcparagraph">	<a name="section-10"><h2>10.  References</h2></a>

	<a name="section-10.1"><h3>10.1  Normative References</h3></a>

   [RFC2608]   Guttman, E., Perkins, C., Veizades, J. and M. Day,
               "Service Location Protocol, Version 2", RFC 2608, June
               1999.

</p><p class="rfcparagraph">   [RFC2119]   Bradner, S., "Key words for use in RFCs to Indicate
               Requirement Levels", BCP 14, RFC 2119, March 1997.
	<a name="section-10.2"><h3>10.2  Informative References</h3></a>

   [RFC1771]   Rekhter, R. and T. Li, "A Border Gateway Protocol 4
               (BGP-4)", RFC 1771, March 1995.

</p><p class="rfcparagraph">   [RFC2610]   Perkins, C. and E. Guttman, "DHCP Options for Service
               Location Protocol", RFC 2610, June, 1999.

</p><p class="rfcparagraph">   [EPID-ALGO] A. Demers, D. Greene, C. Hauser, W. Irish, J. Larson, S.
               Shenker, H. Sturgis, D. Swinehart and D. Terry, "Epidemic
               algorithms for replicated database maintenance", the
               sixth ACM symposium on principles of distributed
               computing, Vancouver, Canada, 1987.

</p><p class="rfcparagraph">   [UPDA-PROP] K. Petersen, M. Spreizer, D. Terry, M. Theimer and A.
               Demers, "Flexible update propagation for weakly
               consistent replication", the sixteenth ACM symposium on
               operating systems principles, Saint Malo, France, 1997.

</p><p class="rfcparagraph">	<a name="section-11"><h2>11.  Authors' Addresses</h2></a>

   Weibin Zhao
   Department of Computer Science
   Columbia University
   1214 Amsterdam Avenue, MC 0401
   New York, NY 10027-7003

   EMail: zwb@cs.columbia.edu


   Henning Schulzrinne
   Department of Computer Science
   Columbia University
   1214 Amsterdam Avenue, MC 0401
   New York, NY 10027-7003

   EMail: hgs@cs.columbia.edu


   Erik Guttman
   Sun Microsystems
   Eichhoelzelstr. 7
   74915 Waibstadt
   Germany

   EMail: Erik.Guttman@sun.com
	<a name="section-12"><h2>12.  Full Copyright Statement</h2></a>

   Copyright (C) The Internet Society (2003).  All Rights Reserved.<br>

</p><p class="rfcparagraph">   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

</p><p class="rfcparagraph">   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

</p><p class="rfcparagraph">   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

</p><p class="rfcparagraph">Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

</p>

















Zhao, et al.                  Experimental                     [Page 15]


      </td>
      <td class=code>
        <div class='highlight'>
            <!--
            <b>Related Stack Overflow questions:</b>
            <ul>
                
            </ul>
            -->
        </div>
      </td>
    </tr>
  </table>
</div>
</body>