<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title></title>
  <link rel="stylesheet" href="static/css/rfc.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1></h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-'>
      <td class=docs>
        <p class="rfcparagraph">Internet Engineering Task Force (IETF)                     R. Seggelmann
Request for Comments: 6520                                     M. Tuexen
Category: Standards Track               Muenster Univ. of Appl. Sciences
ISSN: 2070-1721                                              M. Williams
                                                   GWhiz Arts & Sciences
                                                           February 2012


                   Transport Layer Security (TLS) and
      Datagram Transport Layer Security (DTLS) Heartbeat Extension

<h2>Abstract</h2>

   This document describes the Heartbeat Extension for the Transport
   Layer Security (TLS) and Datagram Transport Layer Security (DTLS)
   protocols.

</p><p class="rfcparagraph">   The Heartbeat Extension provides a new protocol for TLS/DTLS allowing
   the usage of keep-alive functionality without performing a
   renegotiation and a basis for path MTU (PMTU) discovery for DTLS.

</p><p class="rfcparagraph">Status of This Memo

   This is an Internet Standards Track document.

</p><p class="rfcparagraph">   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in Section 2 of RFC 5741.

</p><p class="rfcparagraph">   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   http://www.rfc-editor.org/info/rfc6520.
<h2>Copyright Notice</h2>

   Copyright (c) 2012 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

</p><p class="rfcparagraph">   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

</p><p class="rfcparagraph">Table of Contents
<a href="#section-1" class="">1. Introduction  . . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-2" class="">2. Heartbeat Hello Extension . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3" class="">3. Heartbeat Protocol  . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4" class="">4. Heartbeat Request and Response Messages . . . . . . . . . . . </a><br>
<a href="#section-5" class="">5. Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-6" class="">6. IANA Considerations . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-7" class="">7. Security Considerations . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-8" class="">8. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-9" class="">9. References  . . . . . . . . . . . . . . . . . . . . . . . . . </a><br>

	<a name="section-1"><h2>1.   Introduction</h2></a>

	<a name="section-1.1"><h3>1.1   Overview</h3></a>

   This document describes the Heartbeat Extension for the Transport
   Layer Security (TLS) and Datagram Transport Layer Security (DTLS)
   protocols, as defined in [RFC5246] and [RFC6347] and their
   adaptations to specific transport protocols described in [RFC3436],
   [RFC5238], and [RFC6083].

</p><p class="rfcparagraph">   DTLS is designed to secure traffic running on top of unreliable
   transport protocols.  Usually, such protocols have no session
   management.  The only mechanism available at the DTLS layer to figure
   out if a peer is still alive is a costly renegotiation, particularly
   when the application uses unidirectional traffic.  Furthermore, DTLS
   needs to perform path MTU (PMTU) discovery but has no specific
   message type to realize it without affecting the transfer of user
   messages.
   TLS is based on reliable protocols, but there is not necessarily a
   feature available to keep the connection alive without continuous
   data transfer.

</p><p class="rfcparagraph">   The Heartbeat Extension as described in this document overcomes these
   limitations.  The user can use the new HeartbeatRequest message,
   which has to be answered by the peer with a HeartbeartResponse
   immediately.  To perform PMTU discovery, HeartbeatRequest messages
   containing padding can be used as probe packets, as described in
   [RFC4821].

</p><p class="rfcparagraph">	<a name="section-1.2"><h3>1.2   Conventions</h3></a>

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in [RFC2119].

</p><p class="rfcparagraph">	<a name="section-2"><h2>2.   Heartbeat Hello Extension</h2></a>

   The support of Heartbeats is indicated with Hello Extensions.  A peer
   cannot only indicate that its implementation supports Heartbeats, it
   can also choose whether it is willing to receive HeartbeatRequest
   messages and respond with HeartbeatResponse messages or only willing
   to send HeartbeatRequest messages.  The former is indicated by using
   peer_allowed_to_send as the HeartbeatMode; the latter is indicated by
   using peer_not_allowed_to_send as the Heartbeat mode.  This decision
   can be changed with every renegotiation.  HeartbeatRequest messages
   MUST NOT be sent to a peer indicating peer_not_allowed_to_send.  If
   an endpoint that has indicated peer_not_allowed_to_send receives a
   HeartbeatRequest message, the endpoint SHOULD drop the message
   silently and MAY send an unexpected_message Alert message.

</p><p class="rfcparagraph">   The format of the Heartbeat Hello Extension is defined by:

</p><p class="rfcparagraph">   enum {
      peer_allowed_to_send(1),<br>
      peer_not_allowed_to_send(2),<br>
      (255)
   } HeartbeatMode;

</p><p class="rfcparagraph">   struct {
      HeartbeatMode mode;
   } HeartbeatExtension;

</p><p class="rfcparagraph">   Upon reception of an unknown mode, an error Alert message using
   illegal_parameter as its AlertDescription MUST be sent in response.
	<a name="section-3"><h2>3.   Heartbeat Protocol</h2></a>

   The Heartbeat protocol is a new protocol running on top of the Record
   Layer.  The protocol itself consists of two message types:
   HeartbeatRequest and HeartbeatResponse.

</p><p class="rfcparagraph">   enum {
      heartbeat_request(1),<br>
      heartbeat_response(2),<br>
      (255)
   } HeartbeatMessageType;

</p><p class="rfcparagraph">   A HeartbeatRequest message can arrive almost at any time during the
   lifetime of a connection.  Whenever a HeartbeatRequest message is
   received, it SHOULD be answered with a corresponding
   HeartbeatResponse message.

</p><p class="rfcparagraph">   However, a HeartbeatRequest message SHOULD NOT be sent during
   handshakes.  If a handshake is initiated while a HeartbeatRequest is
   still in flight, the sending peer MUST stop the DTLS retransmission
   timer for it.  The receiving peer SHOULD discard the message
   silently, if it arrives during the handshake.  In case of DTLS,
   HeartbeatRequest messages from older epochs SHOULD be discarded.

</p><p class="rfcparagraph">   There MUST NOT be more than one HeartbeatRequest message in flight at
   a time.  A HeartbeatRequest message is considered to be in flight
   until the corresponding HeartbeatResponse message is received, or
   until the retransmit timer expires.

</p><p class="rfcparagraph">   When using an unreliable transport protocol like the Datagram
   Congestion Control Protocol (DCCP) or UDP, HeartbeatRequest messages
   MUST be retransmitted using the simple timeout and retransmission
   scheme DTLS uses for flights as described in Section 4.2.4 of
   [RFC6347].  In particular, after a number of retransmissions without
   receiving a corresponding HeartbeatResponse message having the
   expected payload, the DTLS connection SHOULD be terminated.  The
   threshold used for this SHOULD be the same as for DTLS handshake
   messages.  Please note that after the timer supervising a
   HeartbeatRequest messages expires, this message is no longer
   considered in flight.  Therefore, the HeartbeatRequest message is
   eligible for retransmission.  The retransmission scheme, in
   combination with the restriction that only one HeartbeatRequest is
   allowed to be in flight, ensures that congestion control is handled
   appropriately in case of the transport protocol not providing one,
   like in the case of DTLS over UDP.
   When using a reliable transport protocol like the Stream Control
   Transmission Protocol (SCTP) or TCP, HeartbeatRequest messages only
   need to be sent once.  The transport layer will handle
   retransmissions.  If no corresponding HeartbeatResponse message has
   been received after some amount of time, the DTLS/TLS connection MAY
   be terminated by the application that initiated the sending of the
   HeartbeatRequest message.

</p><p class="rfcparagraph">	<a name="section-4"><h2>4.   Heartbeat Request and Response Messages</h2></a>

   The Heartbeat protocol messages consist of their type and an
   arbitrary payload and padding.

</p><p class="rfcparagraph">   struct {
      HeartbeatMessageType type;
      uint16 payload_length;
      opaque payload[HeartbeatMessage.payload_length];
      opaque padding[padding_length];
   } HeartbeatMessage;

</p><p class="rfcparagraph">   The total length of a HeartbeatMessage MUST NOT exceed 2^14 or
   max_fragment_length when negotiated as defined in [RFC6066].

</p><p class="rfcparagraph">   type:  The message type, either heartbeat_request or
      heartbeat_response.

</p><p class="rfcparagraph">   payload_length:  The length of the payload.

</p><p class="rfcparagraph">   payload:  The payload consists of arbitrary content.

</p><p class="rfcparagraph">   padding:  The padding is random content that MUST be ignored by the
      receiver.  The length of a HeartbeatMessage is TLSPlaintext.length
      for TLS and DTLSPlaintext.length for DTLS.  Furthermore, the
      length of the type field is 1 byte, and the length of the
      payload_length is 2.  Therefore, the padding_length is
      TLSPlaintext.length - payload_length - 3 for TLS and
      DTLSPlaintext.length - payload_length - 3 for DTLS.  The
      padding_length MUST be at least 16.

</p><p class="rfcparagraph">   The sender of a HeartbeatMessage MUST use a random padding of at
   least 16 bytes.  The padding of a received HeartbeatMessage message
   MUST be ignored.

</p><p class="rfcparagraph">   If the payload_length of a received HeartbeatMessage is too large,
   the received HeartbeatMessage MUST be discarded silently.
   When a HeartbeatRequest message is received and sending a
   HeartbeatResponse is not prohibited as described elsewhere in this
   document, the receiver MUST send a corresponding HeartbeatResponse
   message carrying an exact copy of the payload of the received
   HeartbeatRequest.

</p><p class="rfcparagraph">   If a received HeartbeatResponse message does not contain the expected
   payload, the message MUST be discarded silently.  If it does contain
   the expected payload, the retransmission timer MUST be stopped.

</p><p class="rfcparagraph">	<a name="section-5"><h2>5.   Use Cases</h2></a>

   Each endpoint sends HeartbeatRequest messages at a rate and with the
   padding required for the particular use case.  The endpoint should
   not expect its peer to send HeartbeatRequests.  The directions are
   independent.

</p><p class="rfcparagraph">	<a name="section-5.1"><h3>5.1   Path MTU Discovery</h3></a>

   DTLS performs path MTU discovery as described in Section 4.1.1.1 of
   [RFC6347].  A detailed description of how to perform path MTU
   discovery is given in [RFC4821].  The necessary probe packets are the
   HeartbeatRequest messages.

</p><p class="rfcparagraph">   This method of using HeartbeatRequest messages for DTLS is similar to
   the one for the Stream Control Transmission Protocol (SCTP) using the
   padding chunk (PAD-chunk) defined in [RFC4820].

</p><p class="rfcparagraph">	<a name="section-5.2"><h3>5.2   Liveliness Check</h3></a>

   Sending HeartbeatRequest messages allows the sender to make sure that
   it can reach the peer and the peer is alive.  Even in the case of
   TLS/TCP, this allows a check at a much higher rate than the TCP keep-
   alive feature would allow.

</p><p class="rfcparagraph">   Besides making sure that the peer is still reachable, sending
   HeartbeatRequest messages refreshes the NAT state of all involved
   NATs.

</p><p class="rfcparagraph">   HeartbeatRequest messages SHOULD only be sent after an idle period
   that is at least multiple round-trip times long.  This idle period
   SHOULD be configurable up to a period of multiple minutes and down to
   a period of one second.  A default value for the idle period SHOULD
   be configurable, but it SHOULD also be tunable on a per-peer basis.
	<a name="section-6"><h2>6.   IANA Considerations</h2></a>

   IANA has assigned the heartbeat content type (24) from the "TLS<br>
   ContentType Registry" as specified in [RFC5246].  The reference is to
   RFC 6520.

</p><p class="rfcparagraph">   IANA has created and now maintains a new registry for Heartbeat
   Message Types.  The message types are numbers in the range from 0 to
   255 (decimal).  IANA has assigned the heartbeat_request (1) and the<br>
   heartbeat_response (2) message types.  The values 0 and 255 should be<br>
   reserved.  This registry uses the Expert Review policy as described
   in [RFC5226].  The reference is to RFC 6520.

</p><p class="rfcparagraph">   IANA has assigned the heartbeat extension type (15) from the TLS<br>
   "ExtensionType Values" registry as specified in [RFC5246].  The
   reference is to RFC 6520.

</p><p class="rfcparagraph">   IANA has created and now maintains a new registry for Heartbeat
   Modes.  The modes are numbers in the range from 0 to 255 (decimal).
   IANA has assigned the peer_allowed_to_send (1) and the<br>
   peer_not_allowed_to_send (2) modes.  The values 0 and 255 should be<br>
   reserved.  This registry uses the Expert Review policy as described
   in [RFC5226].  The reference is to RFC 6520.

</p><p class="rfcparagraph">	<a name="section-7"><h2>7.   Security Considerations</h2></a>

   The security considerations of [RFC5246] and [RFC6347] apply to this
   document.  This document does not introduce any new security
   considerations.

</p><p class="rfcparagraph">	<a name="section-8"><h2>8.   Acknowledgments</h2></a>

   The authors wish to thank Pasi Eronen, Adrian Farrel, Stephen
   Farrell, Adam Langley, Nikos Mavrogiannopoulos, Tom Petch, Eric
   Rescorla, Peter Saint-Andre, and Juho Vaehae-Herttua for their
   invaluable comments.

</p><p class="rfcparagraph">	<a name="section-9"><h2>9.   References</h2></a>

	<a name="section-9.1"><h3>9.1   Normative References</h3></a>

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

</p><p class="rfcparagraph">   [RFC5226]  Narten, T. and H. Alvestrand, "Guidelines for Writing an
              IANA Considerations Section in RFCs", BCP 26, RFC 5226,
              May 2008.
   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

</p><p class="rfcparagraph">   [RFC6066]  Eastlake, D., "Transport Layer Security (TLS) Extensions:
              Extension Definitions", RFC 6066, January 2011.

</p><p class="rfcparagraph">   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, January 2012.

</p><p class="rfcparagraph">	<a name="section-9.2"><h3>9.2   Informative References</h3></a>

   [RFC3436]  Jungmaier, A., Rescorla, E., and M. Tuexen, "Transport
              Layer Security over Stream Control Transmission Protocol",
              RFC 3436, December 2002.

</p><p class="rfcparagraph">   [RFC4820]  Tuexen, M., Stewart, R., and P. Lei, "Padding Chunk and
              Parameter for the Stream Control Transmission Protocol
              (SCTP)", RFC 4820, March 2007.

</p><p class="rfcparagraph">   [RFC4821]  Mathis, M. and J. Heffner, "Packetization Layer Path MTU
              Discovery", RFC 4821, March 2007.

</p><p class="rfcparagraph">   [RFC5238]  Phelan, T., "Datagram Transport Layer Security (DTLS) over
              the Datagram Congestion Control Protocol (DCCP)",
              RFC 5238, May 2008.

</p>   [RFC6083]  Tuexen, M., Seggelmann, R., and E. Rescorla, "Datagram
              Transport Layer Security (DTLS) for Stream Control
              Transmission Protocol (SCTP)", RFC 6083, January 2011.
Authors' Addresses

   Robin Seggelmann
   Muenster University of Applied Sciences
   Stegerwaldstr. 39
   48565 Steinfurt
   DE

   EMail: seggelmann@fh-muenster.de


   Michael Tuexen
   Muenster University of Applied Sciences
   Stegerwaldstr. 39
   48565 Steinfurt
   DE

   EMail: tuexen@fh-muenster.de


   Michael Glenn Williams
   GWhiz Arts & Sciences
   2885 Denise Court
   Newbury Park, CA, 91320
   USA

   EMail: michael.glenn.williams@gmail.com
























Seggelmann, et al.           Standards Track                    [Page 9]


      </td>
      <td class=code>
        <div class='highlight'>
            <!--
            <b>Related Stack Overflow questions:</b>
            <ul>
                
            </ul>
            -->
        </div>
      </td>
    </tr>
  </table>
</div>
</body>