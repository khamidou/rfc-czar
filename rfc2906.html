<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title></title>
  <link rel="stylesheet" href="static/css/rfc.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1></h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-'>
      <td class=docs>
        <p class="rfcparagraph"><p>Network Working Group                                        S. Farrell<br>Request for Comments: 2906                       Baltimore Technologies<br>Category: Informational                                   J. Vollbrecht<br>                                               Interlink Networks, Inc.<br>                                                             P. Calhoun<br>                                                 Sun Microsystems, Inc.<br>                                                             L. Gommans<br>                                                Enterasys Networks EMEA<br>                                                               G. Gross<br>                                                    Lucent Technologies<br>                                                           B. de Bruijn<br>                                                Interpay Nederland B.V.<br>                                                             C. de Laat<br>                                                     Utrecht University<br>                                                            M. Holdrege<br>                                                                ipVerse<br>                                                              D. Spence<br>                                               Interlink Networks, Inc.<br>                                                            August 2000<br><br></p>
                  <h1>
                     AAA Authorization Requirements</h1>
                  <h2>Status of this Memo</h2>

   This memo provides information for the Internet community.  It does
   not specify an Internet standard of any kind.  Distribution of this
   memo is unlimited.

</p><p class="rfcparagraph"><h2>Copyright Notice</h2>

   Copyright (C) The Internet Society (2000).  All Rights Reserved.<br>

</p><p class="rfcparagraph"><h2>Abstract</h2>

   This document specifies the requirements that Authentication
   Authorization Accounting (AAA) protocols must meet in order to
   support authorization services in the Internet. The requirements have
   been elicited from a study of a range of applications including
   mobile-IP, roamops and others.
<h2>Table Of Contents</h2>
<a href="#section-1" class="">1. Introduction................................................</a><br>
<a href="#section-2" class="">2. Requirements................................................</a><br>
<a href="#section-2.1" class="indent-1">2.1 Authorization Information.............................</a><br>
<a href="#section-2.2" class="indent-1">2.2 Security of authorization information.................</a><br>
<a href="#section-2.3" class="indent-1">2.3 Time..................................................</a><br>
<a href="#section-2.4" class="indent-1">2.4 Topology.............................................</a><br>
<a href="#section-2.5" class="indent-1">2.5 Application Proxying.................................</a><br>
<a href="#section-2.6" class="indent-1">2.6 Trust Model..........................................</a><br>
<a href="#section-2.7" class="indent-1">2.7 Not just transactions................................</a><br>
<a href="#section-2.8" class="indent-1">2.8 Administration.......................................</a><br>
<a href="#section-2.9" class="indent-1">2.9 Bytes on-the-wire....................................</a><br>
<a href="#section-2.10" class="indent-1">2.10 Interfaces...........................................</a><br>
<a href="#section-2.11" class="indent-1">2.11 Negotiation..........................................</a><br>
<a href="#section-3" class="">3. Security Considerations....................................</a><br>
<a href="#section-4" class="">4. References.................................................</a><br>
   Authors' Addresses.............................................20
   Full Copyright Statement.......................................23

	<a name="section-1"><h2>1.  Introduction</h2></a>

   This document is one of a series of three documents under
   consideration by the AAAarch RG dealing with the authorization
   requirements for AAA protocols.  The three documents are:

</p><p class="rfcparagraph">         AAA Authorization Framework [FRMW]
         AAA Authorization Requirements (this document)
         AAA Authorization Application Examples [SAMP]

   The work for this memo was done by a group that originally was the
   Authorization subgroup of the AAA Working Group of the IETF.  When
   the charter of the AAA working group was changed to focus on MobileIP
   and NAS requirements, the AAAarch Research Group was chartered within
   the IRTF to continue and expand the architectural work started by the
   Authorization subgroup.  This memo is one of four which were created
   by the subgroup.  This memo is a starting point for further work
   within the AAAarch Research Group.  It is still a work in progress
   and is published so that the work will be available for the AAAarch
   subgroup and others working in this area, not as a definitive
   description of architecture or requirements.

</p><p class="rfcparagraph">   The process followed in producing this document was to analyze the
   requirements from [SAMP] based on a common understanding of the AAA
   authorization framework [FRMW]. This document assumes familiarity
   with both the general issues involved in authorization and, in
   particular, the reader will benefit from a reading of [FRMW] where,
   for example, definitions of terms can be found.
   The key words "MUST", "REQUIRED", "SHOULD", "RECOMMENDED", and "MAY"
   in this document are to be interpreted as described in [RFC2119].

</p><p class="rfcparagraph">	<a name="section-2"><h2>2.  Requirements</h2></a>

   Requirements are grouped under headings for convenience; this
   grouping is not significant.

</p><p class="rfcparagraph">   Definitions and explanations of some of the technical terms used in
   this document may be found in [FRMW].

</p><p class="rfcparagraph">   Each requirement is presented as a succinct (usually a sentence or
   two) statement. Most are followed by a paragraph of explanatory
   material, which sometimes contains an example. Fully described
   examples may be found in [SAMP].

</p><p class="rfcparagraph">   The requirements presented are not intended to be "orthogonal", that
   is, some of them repeat, or overlap, with others.

</p><p class="rfcparagraph">	<a name="section-2.1"><h3>2.1  Authorization Information</h3></a>

	<a name="section-2.1.1"><h4>2.1.1    Authorization decisions MUST be able to be based on information</h4></a>
   about the requestor, the service/method requested, and the operating
   environment (authorization information). AAA protocols are required
   to transport this information.

</p><p class="rfcparagraph">   This simply states the requirement for a protocol and an access
   decision function, which takes inputs, based on the requestor, the
   resource requested and the environment.

</p><p class="rfcparagraph">	<a name="section-2.1.2"><h4>2.1.2    It MUST be possible to represent authorization information as</h4></a>
   sets of attributes. It MAY be possible to represent authorization
   information as objects.

</p><p class="rfcparagraph">   This states that authorization information must be decomposable into
   sets of attributes. It is not intended to imply any particular
   mechanism for representing attributes.

</p><p class="rfcparagraph">	<a name="section-2.1.3"><h4>2.1.3    It MUST be possible to package authorization information so that</h4></a>
   the authorization information for multiple services or applications
   can be carried in a single message in a AAA or application protocol.

</p><p class="rfcparagraph">   This states that a protocol, which always required separate AAA
   messages/transactions for each service/application, would not meet
   the requirement. For example, it should be possible for a single AAA
   message/transaction to be sufficient to allow both network and
   application access.
	<a name="section-2.1.4"><h4>2.1.4    Standard attributes types SHOULD be defined which are relevant</h4></a>
   to many Internet applications/services (e.g.  identity information,
   group information, ...)

   There are many attributes that are used in lots of contexts, and
   these should only be defined once, in order to promote
   interoperability and prevent duplication of effort.

</p><p class="rfcparagraph">	<a name="section-2.1.5"><h4>2.1.5    Authorization decisions MUST NOT be limited to being based on</h4></a>
   identity information, i.e. AAA protocols MUST support the use of
   non-identifying information, e.g. to support role based access
   control (RBAC).

</p><p class="rfcparagraph">   Authorization based on clearances, roles, groups or other information
   is required to be supported. A AAA protocol that only carried
   identity information would not meet the requirement.

</p><p class="rfcparagraph">	<a name="section-2.1.6"><h4>2.1.6    Authorization data MAY include limits in addition to attributes</h4></a>
   which are directly "owned" by end entities.

</p><p class="rfcparagraph">   This states that some attributes do not simply represent attributes
   of an entity, for example a spending limit of IR 1,000 is not an
   intrinsic attribute of an entity. This also impacts on the access
   decision function, in that the comparison to be made is not a simple
   equality match.

</p><p class="rfcparagraph">	<a name="section-2.1.7"><h4>2.1.7    It MUST be possible for other (non-AAA) protocols to define</h4></a>
   their own attribute types, which can then be carried within an
   authorization package in a AAA or application protocol.

</p><p class="rfcparagraph">   This states that the attributes that are significant in an
   authorization decision, may be application protocol dependent. For
   example, many attribute types are defined by [RFC2138] and support
   for the semantics of these attributes will be required. Of course,
   only AAA entities that are aware of the added attribute types can
   make use of them.

</p><p class="rfcparagraph">	<a name="section-2.1.8"><h4>2.1.8    It SHOULD be possible for administrators of deployed systems to</h4></a>
   define their own attribute types, which can then be carried within an
   authorization package in a AAA or application protocol.

</p><p class="rfcparagraph">   This states that the attributes that are significant in an
   authorization decision, may be dependent on a closed environment.
   For example, many organizations have a well-defined scheme of
   seniority, which can be used to determine access levels. Of course,
   only AAA entities that are aware of the added attribute types can
   make use of them.
	<a name="section-2.1.9"><h4>2.1.9    It SHOULD be possible to define new attribute types without</h4></a>
   central administration and control of attribute name space.

</p><p class="rfcparagraph">   A centralized or distributed registration scheme of some sort is
   needed if collisions in attribute type allocations are to be avoided.
   However a AAA protocol which always requires use of such a
   centralized registration would not meet the requirement. Of course,
   collisions should be avoided where possible.

</p><p class="rfcparagraph">	<a name="section-2.1.10"><h4>2.1.10   It MUST be possible to define attribute types so that an</h4></a>
   instance of an attribute in a single AAA message can have multiple
   values.

</p><p class="rfcparagraph">   This states that a protocol which does not allow multiple instances
   of an attribute in a message/transaction would not meet the
   requirement.  For example it should be possible to have a "group"
   attribute which contains more than one groupname (or number or
   whatever).

</p><p class="rfcparagraph">	<a name="section-2.1.11"><h4>2.1.11   If MUST be possible to distinguish different instances of the</h4></a>
   same authorization attribute type or value, on the basis of "security
   domain" or "authority".

</p><p class="rfcparagraph">   This recognizes that it is important to be able to distinguish
   between attributes based not only on their value. For example, all NT
   domains (which use the English language) have an Administrators
   group, an access decision function has to be able to determine to
   which of these groups the requestor belongs.

</p><p class="rfcparagraph">	<a name="section-2.1.12"><h4>2.1.12   AAA protocols MUST specify mechanisms for updating the rules</h4></a>
   which will be used to control authorization decisions.

</p><p class="rfcparagraph">   This states that a AAA protocol that cannot provide a mechanism for
   distributing authorization rules is not sufficient. For example, this
   could be used to download ACLs to a PDP.

</p><p class="rfcparagraph">   Note that this is not meant to mean that this AAA protocol mechanism
   must always be used, simply that it must be available for use. In
   particular, storing authorization rules in a trusted repository (in
   many cases an LDAP server) will in many cases be used instead of such
   a AAA protocol mechanism.  Neither does this requirement call for a
   standardized format for authorization rules, merely that there be a
   mechanism for transporting these.
	<a name="section-2.1.13"><h4>2.1.13   The AAA protocol MUST allow for chains of AAA entities to be</h4></a>
   involved in an authorization decision.

</p><p class="rfcparagraph">   This states that more than one AAA server may have to be involved in
   a single authorization decision. This may occur either due to a
   decision being spread across more than one "domain" or in order to
   distribute authorization within a single "domain".

</p><p class="rfcparagraph">	<a name="section-2.1.14"><h4>2.1.14   The AAA protocol MUST allow for intermediate AAA entities to add</h4></a>
   their own local authorization information to a AAA request or
   response.

</p><p class="rfcparagraph">   This states that where more than one AAA entity is involved in an
   authorization decision each of the AAA entities may manipulate the
   AAA messages involved either by adding more information or by
   processing parts of the information.

</p><p class="rfcparagraph">	<a name="section-2.1.15"><h4>2.1.15   AAA entities MAY be either be deployed independently or</h4></a>
   integrated with application entities.

</p><p class="rfcparagraph">   This states that the AAA entities may either be implemented as AAA
   servers or integrated with application entities.

</p><p class="rfcparagraph">	<a name="section-2.1.16"><h4>2.1.16   The AAA protocol MUST support the creation and encoding of rules</h4></a>
   that are to be active inside one AAA server based on attributes
   published by another AAA server. The level of authorization of the
   requesting AAA Server MAY govern the view on attributes.

</p><p class="rfcparagraph">   This states that one AAA entity may have to distribute authorization
   rules to another, and that the AAA entity that receives the rules may
   only be seeing part of the story.

</p><p class="rfcparagraph">	<a name="section-2.1.17"><h4>2.1.17   AAA protocols MAY have to support the idea of critical and non-</h4></a>
   critical attribute types.

</p><p class="rfcparagraph">   This is analogous to the use of the criticality flag in public key
   certificate extensions.

</p><p class="rfcparagraph">	<a name="section-2.1.18"><h4>2.1.18   A AAA protocol MUST allow authorization rules to be expressed in</h4></a>
   terms of combinations of other authorization rules which have been
   evaluated.

</p><p class="rfcparagraph">   For example, access may only be granted if the requestor is member of
   the backup users group and not a member of the administrator's group.
   Note that this requirement does not state which types of combinations
   are to be supported.
	<a name="section-2.1.19"><h4>2.1.19   It SHOULD be possible to make authorization decisions based on</h4></a>
   the geographic location of a requestor, service or AAA entity.

</p><p class="rfcparagraph">   This is just an example of an authorization attribute type, notable
   because it requires different underlying implementation mechanisms.

</p><p class="rfcparagraph">	<a name="section-2.1.20"><h4>2.1.20   It SHOULD be possible to make authorization decisions based on</h4></a>
   the identity or the equipment used by a requestor, service or AAA
   entity.

</p><p class="rfcparagraph">   This is just an example of an authorization attribute type, notable
   because it may require different underlying implementation mechanisms
   (if IPSec isn't available).

</p><p class="rfcparagraph">	<a name="section-2.1.21"><h4>2.1.21   When there are multiple instances of a given attribute, there</h4></a>
   must be an unambiguous mechanism by which a receiving peer can
   determine the value of specified instance.

</p><p class="rfcparagraph">	<a name="section-2.2"><h3>2.2  Security of authorization information</h3></a>

	<a name="section-2.2.1"><h4>2.2.1    It MUST be possible for authorization information to be</h4></a>
   communicated securely in AAA and application protocols.  Mechanisms
   that preserve authenticity, integrity and privacy for this
   information MUST be specified.

</p><p class="rfcparagraph">   This states that there must be a well-defined method for securing
   authorization information, not that such methods must always be used.
   Whether support for these mechanisms is to be required for
   conformance is left open. In particular, mechanisms must be provided
   so that a service administrator in the middle of a chain cannot read
   or change authorization information being sent between other AAA
   entities.

</p><p class="rfcparagraph">	<a name="section-2.2.2"><h4>2.2.2    AAA protocols MUST allow for use of an appropriate level of</h4></a>
   security for authorization information. AAA protocols MUST be able to
   support both highly secure and less secure mechanisms for data
   integrity/confidentiality etc.

</p><p class="rfcparagraph">   It is important that AAA protocols do not mandate too heavy a
   security overhead, thus the security mechanisms specified don't
   always need to be used (though not using them may affect the
   authorization decision).

</p><p class="rfcparagraph">	<a name="section-2.2.3"><h4>2.2.3    The security requirements MAY differ between different parts of</h4></a>
   a package of authorization information.

</p><p class="rfcparagraph">   Some parts may require confidentiality and integrity, some may only
   require integrity. This effectively states that we require something
   like selective field security mechanisms. For example, information
   required to gain access to a network may have to be in clear, whilst
   information required for access to an application within that network
   may have to be encrypted in the AAA protocol.

</p><p class="rfcparagraph">	<a name="section-2.2.4"><h4>2.2.4    AAA protocols MUST provide mechanisms that prevent intermediate</h4></a>
   administrators breaching security.

</p><p class="rfcparagraph">   This is a basic requirement to prevent man-in-the-middle attacks, for
   example where an intermediate administrator changes AAA messages on
   the fly.

</p><p class="rfcparagraph">	<a name="section-2.2.5"><h4>2.2.5    AAA protocols MUST NOT open up replay attacks based on replay of</h4></a>
   the authorization information.

</p><p class="rfcparagraph">   For example, a AAA protocol should not allow flooding attacks where
   the attacker replays AAA messages that require the recipient to use a
   lot of CPU or communications before the replay is detected.

</p><p class="rfcparagraph">	<a name="section-2.2.6"><h4>2.2.6    AAA protocols MUST be capable of leveraging any underlying peer</h4></a>
   entity authentication mechanisms that may have been applied - this
   MAY provide additional assurance that the owner of the authorization
   information is the same as the authenticated entity.  For example, if
   IPSec provides sufficient authentication, then it must be possible to
   omit AAA protocol authentication.

</p><p class="rfcparagraph">	<a name="section-2.2.7"><h4>2.2.7    End-to-end confidentiality, integrity, peer-entity-</h4></a>
   authentication, or non-repudiation MAY be required for packages of
   authorization information.

</p><p class="rfcparagraph">   This states that confidentiality, (resp. the other security
   services), may have to be provided for parts of a AAA message, even
   where it is transmitted via other AAA entities. It does allow that
   such a AAA message may also contain non-confidential, resp. the other
   security services), parts. In addition, intermediate AAA entities may
   themselves be considered end-points for end-to-end security services
   applied to other parts of the AAA message.

</p><p class="rfcparagraph">	<a name="section-2.2.8"><h4>2.2.8    AAA protocols MUST be usable even in environments where no peer</h4></a>
   entity authentication is required (e.g. a network address on a secure
   LAN may be enough to decide).

</p><p class="rfcparagraph">   This requirement (in a sense the opposite of 2.2.6), indicates the
   level of flexibility that is required in order to make the AAA
   protocol useful across a broad range of applications/services.
	<a name="section-2.2.9"><h4>2.2.9    AAA protocols MUST specify "secure" defaults for all protocol</h4></a>
   options. Implementations of AAA entities MUST use these "secure"
   defaults unless otherwise configured/administered.

</p><p class="rfcparagraph">   This states that the out-of-the-box configuration must be "secure",
   for example, authorization decisions should result in denial of
   access until a AAA entity is configured. Note that the interpretation
   of "secure" will vary on a case-by-case basis, though the principle
   remains the same.

</p><p class="rfcparagraph">	<a name="section-2.3"><h3>2.3  Time</h3></a>

	<a name="section-2.3.1"><h4>2.3.1    Authorization information MUST be timely, which means that it</h4></a>
   MUST expire and in some cases MAY be revoked before expiry.

</p><p class="rfcparagraph">   This states that authorization information itself is never to be
   considered valid for all time, every piece of authorization
   information must have associated either an explicit or implicit
   validity period or time-to-live.

</p><p class="rfcparagraph">	<a name="section-2.3.2"><h4>2.3.2    AAA protocols MUST provide mechanisms for revoking authorization</h4></a>
   information, in particular privileges.

</p><p class="rfcparagraph">   Where the validity or time-to-live is long, it may be necessary to
   revoke the authorization information, e.g. where someone leaves a
   company. Note that this requirement does not mandate a particular
   scheme for revocation, so that it is not a requirement for blacklists
   or CRLs.

</p><p class="rfcparagraph">	<a name="section-2.3.3"><h4>2.3.3    A set of attributes MAY have an associated validity period -</h4></a>
   such that that the set MUST only be used for authorization decisions
   during that period. The validity period may be relatively long, (e.g.
   months) or short (hours, minutes).

</p><p class="rfcparagraph">   This states that explicit validity periods are, in some cases, needed
   at the field level.

</p><p class="rfcparagraph">	<a name="section-2.3.4"><h4>2.3.4    Authorization decisions MAY be time sensitive. Support for e.g.</h4></a>
   "working hours" or equivalent MUST be possible.

</p><p class="rfcparagraph">   This states that the AAA protocol must be able to support the
   transmission of time control attributes, although it does not mandate
   that AAA protocols must include a standard way of expressing the
   "working hours" type constraint.
	<a name="section-2.3.5"><h4>2.3.5    It MUST be possible to support authorization decisions that</h4></a>
   produce time dependent results.

</p><p class="rfcparagraph">   For example, an authorization result may be that service should be
   provided for a certain period. In such cases a AAA protocol must be
   able to transport this information, possibly as a specific result of
   the authorization decision, or, as an additional "termination of
   service" AAA message transmitted later.

</p><p class="rfcparagraph">	<a name="section-2.3.6"><h4>2.3.6    It MUST be possible to support models where the authorization</h4></a>
   information is issued in well in advance of an authorization decision
   rather than near the time of the authorization decision.

</p><p class="rfcparagraph">   This is required in order to support pre-paid (as opposed to
   subscription) scenarios (e.g. for VoIP).

</p><p class="rfcparagraph">	<a name="section-2.3.7"><h4>2.3.7    It SHOULD be possible to support models where the authorization</h4></a>
   decision is made in advance of a service request.

</p><p class="rfcparagraph">   This is for some applications such as backup, where actions are
   scheduled for future dates. It also covers applications that require
   reservation of resources.

</p><p class="rfcparagraph">	<a name="section-2.3.8"><h4>2.3.8    A AAA mechanism must allow time stamp information to be carried</h4></a>
   along with authorization information (e.g. for non-repudiation).

</p><p class="rfcparagraph">   The PKIX WG is developing a time stamp protocol, which can be used as
   part of a non-repudiation solution. In some environments it may be
   necessary that certain AAA protocol messages are timestamped (by a
   trusted authority) and that the timestamps are forwarded within
   subsequent AAA messages.

</p><p class="rfcparagraph">	<a name="section-2.4"><h3>2.4  Topology</h3></a>

	<a name="section-2.4.1"><h4>2.4.1    AAA protocols MUST be able to support the use of the push, pull</h4></a>
   and agent models.

</p><p class="rfcparagraph">   This states that a protocol that only supported one model, say pull,
   would not meet the requirements of all the applications. The models
   are defined in [FRMW].

</p><p class="rfcparagraph">	<a name="section-2.4.2"><h4>2.4.2    In transactions/sessions, which involve more than one AAA</h4></a>
   entity, each "hop" MAY use a different push/pull/agent model.

</p><p class="rfcparagraph">   For example, in the mobile IP case, a "foreign" AAA server might pull
   authorization information from a broker, whereas the broker might
   push some authorization information to a "home" AAA server.
	<a name="section-2.4.3"><h4>2.4.3    AAA Protocols MUST cater for applications and services where the</h4></a>
   entities involved in the application or AAA protocols belong to
   different (security) domains.

</p><p class="rfcparagraph">   This states that it must be possible for any AAA protocol message to
   cross security or administrative domain boundaries. Typically, higher
   levels of security will be applied when crossing such boundaries, and
   accounting mechanisms may also have to be more stringent.

</p><p class="rfcparagraph">	<a name="section-2.4.4"><h4>2.4.4    AAA protocols MUST support roaming.</h4></a>

   Roaming here may also be thought of as "away-from-home" operation.
   For example, this is a fundamental requirement for the mobile IP
   case.

</p><p class="rfcparagraph">	<a name="section-2.4.5"><h4>2.4.5    AAA protocols SHOULD support dynamic mobility</h4></a>

   Dynamic mobility here means that a client moves from one domain to
   another, without having to completely re-establish e.g. whatever AAA
   session information is being maintained.

</p><p class="rfcparagraph">	<a name="section-2.4.6"><h4>2.4.6    An authorization decision MAY have to be made before the</h4></a>
   requestor has any other connection to a network.

</p><p class="rfcparagraph">   For example, this means that the requestor can't go anywhere on the
   network to fetch anything and must do requests via an
   application/service or via an intermediate AAA entity. The AAA
   protocol should not overexpose such a server to denial-of-service
   attacks.

</p><p class="rfcparagraph">	<a name="section-2.4.7"><h4>2.4.7    AAA protocols MUST support the use of intermediate AAA entities</h4></a>
   which take part in authorization transactions but which don't "own"
   any of the end entities or authorization data.

</p><p class="rfcparagraph">   In some environments (e.g. roamops), these entities are termed
   brokers (though these are not the same as bandwidth brokers in the
   QoS environment).

</p><p class="rfcparagraph">	<a name="section-2.4.8"><h4>2.4.8    AAA protocols MAY support cases where an intermediate AAA entity</h4></a>
   returns a forwarding address to a requestor or AAA entity, in order
   that the requestor or originating AAA entity can contact another AAA
   entity.

</p><p class="rfcparagraph">   This requirement recognizes that there will be routing issues with
   AAA servers, and that this requires that AAA protocols are able to
   help with such routing. For example, in the mobile IP case, a broker
   may be required, in part to allow the foreign and home AAA servers to
   get in contact.
	<a name="section-2.4.9"><h4>2.4.9    It MUST be possible for an access decision function to discover</h4></a>
   the AAA server of a requestor. If the requestor provides information
   used in this discovery process then the access decision function MUST
   be able to verify this information in a trusted manner.

</p><p class="rfcparagraph">   This states that not only do AAA servers have to be able to find one
   another, but that sometimes an application entity may have to find an
   appropriate AAA server.

</p><p class="rfcparagraph">	<a name="section-2.5"><h3>2.5  Application Proxying</h3></a>

	<a name="section-2.5.1"><h4>2.5.1    AAA protocols MUST support cases where applications use proxies,</h4></a>
   that is, an application entity (C), originates a service request to a
   peer (I) and this intermediary (I) also initiates a service request
   on behalf of the client (C) to a final target (T).  AAA protocols
   MUST be such that the authorization decision made at T, MAY depend on
   the authorization information associated with C and/or with I. This
   "application proxying" must not introduce new security weaknesses in
   the AAA protocols. There MAY be chains of application proxies of any
   length.

</p><p class="rfcparagraph">   Note that this requirement addresses application layer proxying - not
   chains of AAA servers. For example, a chain of HTTP proxies might
   each want to restrict the content they serve to the "outside".  As
   the HTTP GET message goes from HTTP proxy to HTTP proxy, this
   requirement states that it must be possible that the authorization
   decisions made at each stage can depend on the user at the browser,
   and not say, solely on the previous HTTP proxy's identity. Of course
   there may only be a single AAA server involved, or there may be many.

</p><p class="rfcparagraph">	<a name="section-2.5.2"><h4>2.5.2    Where there is a chain of application proxies, the AAA protocol</h4></a>
   flows at each stage MAY be independent, i.e. the first hop may use
   the push model, the second pull, the third the agent model.

</p><p class="rfcparagraph">   This simply restates a previous requirement (no. 2.4.7), to make it
   clear that this also applies when application proxying is being used.

</p><p class="rfcparagraph">	<a name="section-2.6"><h3>2.6  Trust Model</h3></a>

	<a name="section-2.6.1"><h4>2.6.1    AAA entities MUST be able to make decisions about which other</h4></a>
   AAA entities are trusted for which sorts of authorization
   information.

</p><p class="rfcparagraph">   This is analogous to a requirement in public key infrastructures:
   Just because someone can produce a cryptographically correct public
   key certificate does not mean that I should trust them for anything,
   in particular, I might trust the issuer for some purposes, but not
   for others.
	<a name="section-2.6.2"><h4>2.6.2    AAA protocols MUST allow entities to be trusted for different</h4></a>
   purposes, trust MUST NOT be an all-or-nothing issue.

</p><p class="rfcparagraph">   This relates the packaging (no. 2.1.3) and trust (no. 2.6.1)
   requirements. For example, a AAA entity may trust some parts of an
   authorization package but not others.

</p><p class="rfcparagraph">	<a name="section-2.6.3"><h4>2.6.3    A confirmation of authorization MAY be required in order to</h4></a>
   initialize or resynchronize a AAA entity.

</p><p class="rfcparagraph">   This states that a AAA entity may need to process some AAA protocol
   messages in order to initialize itself. In particular, a AAA entity
   may need to check that a previous AAA message remains "valid", e.g.
   at boot-time.

</p><p class="rfcparagraph">	<a name="section-2.6.4"><h4>2.6.4    A negation of static authorization MAY be required to shut down</h4></a>
   certain services.

</p><p class="rfcparagraph">   This is the converse of 2.6.5 above. It means that a AAA entity may
   be "told" by another that a previous AAA message is no longer
   "valid". See also 2.3.2 and 2.7.6.

</p><p class="rfcparagraph">	<a name="section-2.6.5"><h4>2.6.5    It MUST be possible to configure sets of AAA entities that</h4></a>
   belong to a local domain, so that they are mutually trusting, but so
   that any external trust MUST be via some nominated subset of AAA
   entities.

</p><p class="rfcparagraph">   This states that for efficiency or organizational reasons, it must be
   possible to set up some AAA servers through which all "external" AAA
   services are handled. It also states that it must be possible to do
   this without over-burdening the "internal-only" AAA servers with
   onerous security mechanisms, just because some AAA servers do handle
   external relations.

</p><p class="rfcparagraph">	<a name="section-2.6.6"><h4>2.6.6    Intermediate AAA entities in a chain MUST be able to refuse a</h4></a>
   connection approved by an earlier entity in the chain.

</p><p class="rfcparagraph">   For example, in mobile IP the home network may authorize a
   connection, but the foreign network may refuse to allow the
   connection due to the settings chosen by the home network, say if the
   home network will refuse to pay.

</p><p class="rfcparagraph">	<a name="section-2.6.7"><h4>2.6.7    It SHOULD be possible to modify authorization for resources</h4></a>
   while a session is in progress without destroying other session
   information.
   For example, a "parent" AAA server should be able to modify the
   authorization state of sessions managed by a "child" AAA server, say
   by changing the maximum number of simultaneous sessions which are
   allowed.

</p><p class="rfcparagraph">	<a name="section-2.7"><h3>2.7  Not just transactions</h3></a>

	<a name="section-2.7.1"><h4>2.7.1    Authorization decisions MAY be context sensitive, AAA protocols</h4></a>
   MUST enable such decisions.

</p><p class="rfcparagraph">   This states that AAA protocols need to support cases where the
   authorization depends, (perhaps even only depends), on the current
   state of the system, e.g. only seven sessions allowed, seventh
   decision depends on existence of six current sessions. Since the
   context might involve more than one service, the AAA protocol is
   likely to have to offer some support.

</p><p class="rfcparagraph">	<a name="section-2.7.2"><h4>2.7.2    AAA protocols SHOULD support both the authorization of</h4></a>
   transactions and continuing authorization of sessions.

</p><p class="rfcparagraph">   This states that AAA entities may have to maintain state and act when
   the state indicates some condition has been met.

</p><p class="rfcparagraph">	<a name="section-2.7.3"><h4>2.7.3    Within a single session or transaction, it MUST be possible to</h4></a>
   interleave authentication, authorization and accounting AAA messages.

</p><p class="rfcparagraph">   This states, that e.g. a session may have to use initial
   authentication, authorization and accounting AAA message(s), but also
   have to include e.g. re-authentication every 30 minutes, or a
   continuous "drip-drip" of accounting AAA messages.

</p><p class="rfcparagraph">	<a name="section-2.7.4"><h4>2.7.4    Authorization decisions may result in a "not ready" answer.</h4></a>

   This states that yes and no are not the only outcomes of an
   authorization decision. In particular, if the AAA entity cannot yet
   give a decision, it might have to return such a result. This is
   analogous to how public key certification requests are sometimes
   handled in PKI management protocols.

</p><p class="rfcparagraph">	<a name="section-2.7.5"><h4>2.7.5    A AAA entity MAY re-direct a AAA request that it has received.</h4></a>

   This states that if entity "a" asks "b", then "b" may say: "don't ask
   me, ask 'c'". This is analogous to HTTP re-direction (status code
   307).

</p><p class="rfcparagraph">	<a name="section-2.7.6"><h4>2.7.6    AAA protocols SHOULD allow a AAA entity to "take back" an</h4></a>
   authorization.
   The expectation is that AAA protocols will support the ability of a
   AAA entity to signal an application or other AAA entity that an
   authorization (possibly previously granted by a third AAA entity) is
   no longer valid.

</p><p class="rfcparagraph">	<a name="section-2.8"><h3>2.8  Administration</h3></a>

	<a name="section-2.8.1"><h4>2.8.1    It MUST be possible for authorization data to be administered on</h4></a>
   behalf of the end entities and AAA entities.

</p><p class="rfcparagraph">   This requirement indicates that administration of AAA has to be
   considered as part of protocol design - a AAA protocol, which
   required all AAA entities act independent of all other AAA entities,
   would not meet the requirement.

</p><p class="rfcparagraph">	<a name="section-2.8.2"><h4>2.8.2    Centralizable administration of all features SHOULD be</h4></a>
   supported.

</p><p class="rfcparagraph">   It should be possible (if it meets the domain requirements) to
   centralize or distribute the administration of AAA.

</p><p class="rfcparagraph">	<a name="section-2.8.3"><h4>2.8.3    AAA protocols SHOULD support cases where the user (as opposed to</h4></a>
   an administrator) authorizes a transaction.

</p><p class="rfcparagraph">   For example, a user might want to control anti-spam measures or
   authorize things like a purchase. In such cases, the user is acting
   somewhat like an administrator.

</p><p class="rfcparagraph">	<a name="section-2.8.4"><h4>2.8.4    One AAA entity MAY create authorization rules for another AAA</h4></a>
   entity.

</p><p class="rfcparagraph">   This is required to properly support delegation of authority, however
   when allowed, this must be able to be done in a secure fashion.

</p><p class="rfcparagraph">	<a name="section-2.8.5"><h4>2.8.5    AAA protocols SHOULD support failure recovery when one AAA</h4></a>
   entity in a chain of AAA entities that maintain state about a session
   fails.

</p><p class="rfcparagraph">   For example, in a network access situation it may be required that a
   AAA server which has crashed be able to determine how many sessions
   are in progress, in order to make the "next" authorization decision.

</p><p class="rfcparagraph">	<a name="section-2.8.6"><h4>2.8.6    It SHOULD be possible for a AAA entity to query the</h4></a>
   authorization state of another AAA entity.

</p><p class="rfcparagraph">   This may be required as part of a failure recovery procedure.
	<a name="section-2.8.7"><h4>2.8.7    AAA protocols MUST be able to support "hot fail-over" for server</h4></a>
   components without loss of state information.

</p><p class="rfcparagraph">   This states that AAA protocols must be able to support cases where,
   when a server is no longer operable, a secondary server can
   automatically be brought "live" without losing important state
   information.

</p><p class="rfcparagraph">	<a name="section-2.9"><h3>2.9  Bytes on-the-wire</h3></a>

	<a name="section-2.9.1"><h4>2.9.1    Authorization separate from authentication SHOULD be allowed</h4></a>
   when necessary, but the AAA protocols MUST also allow for a single
   message to request both authentication and authorization.

</p><p class="rfcparagraph">   AAA protocols have to allow a split between authentication and
   authorization so that different mechanisms are used for each. This
   states that sometimes both types of information need to be carried in
   the same message.

</p><p class="rfcparagraph">	<a name="section-2.9.2"><h4>2.9.2    In order to minimize resource usage (e.g. reduce roundtrips) it</h4></a>
   MUST be possible to embed AAA PDUs into other protocols.

</p><p class="rfcparagraph">   This states that the AAA protocol authorization packages must be
   defined so that they can also be carried in other protocols. For
   example, depending on AAA protocol header information in order to
   reference an authorization package could cause a protocol to fail to
   meet the requirement.

</p><p class="rfcparagraph">	<a name="section-2.9.3"><h4>2.9.3    A AAA protocol MAY provide mechanisms for replication of state</h4></a>
   information.

</p><p class="rfcparagraph">   This can be required e.g. to support resiliency in cases where hot
   fail-over is required. Note that AAA protocols are of course, subject
   to normal protocol design requirements to do with reliability, no
   single-point-of-failure etc even though these are not all specified
   here.

</p><p class="rfcparagraph">	<a name="section-2.9.4"><h4>2.9.4    A AAA protocol SHOULD allow the possibility for implementation</h4></a>
   of a gateway function between the AAA protocol and other legacy AAA
   related protocols.

</p><p class="rfcparagraph">   For example, some form of support for [RFC2138] as a legacy protocol
   is very likely to be required. Of course, the use of such a gateway
   is almost certain to mean not meeting some other requirements, (e.g.
   end-to-end security), for transactions routed through the gateway.
   There is no implication that such gateway functionality needs to be a
   separate server.
	<a name="section-2.9.5"><h4>2.9.5    A AAA protocol MUST be able to support use of a wide range of</h4></a>
   primitive data types, including RFC2277.

</p><p class="rfcparagraph">   For example, various sized, signed and unsigned integers, possibly
   including multi-precision integers will almost certainly need to be
   transported. Floating point support according to ANSI IEEE 754-1985
   may also be required.

</p><p class="rfcparagraph">	<a name="section-2.9.6"><h4>2.9.6    A AAA protocol transport SHOULD support being optimized for a</h4></a>
   long-term exchange of small packets in a stream between a pair of
   hosts.

</p><p class="rfcparagraph">   NASes typically have a high number of transactions/second, so the AAA
   protocol MUST allow the flow of requests to be controlled in order
   for the server to make efficient use of it's receive buffers.

</p><p class="rfcparagraph">	<a name="section-2.9.7"><h4>2.9.7    A AAA protocol MUST provide support for load balancing.</h4></a>

   In the event that a peer's cannot receive any immediate requests, the
   AAA protocol MUST allow for an implementation to balance the load of
   requests among a set of peers.

</p><p class="rfcparagraph">	<a name="section-2.10"><h3>2.10     Interfaces</h3></a>

	<a name="section-2.10.1"><h4>2.10.1   It SHOULD be possible that authorization data can be used for</h4></a>
   application purposes.

</p><p class="rfcparagraph">   For example, in web access, if the authorization data includes a
   group name, mechanisms to make this data available to the application
   so that it can modify the URL originally requested are desirable.

</p><p class="rfcparagraph">	<a name="section-2.10.2"><h4>2.10.2   It SHOULD be possible that authorization data can be used to</h4></a>
   mediate the response to a request.

</p><p class="rfcparagraph">   For example, with web access the clearance attribute value may affect
   the content of the HTTP response message.

</p><p class="rfcparagraph">	<a name="section-2.10.3"><h4>2.10.3   AAA protocols SHOULD be able to operate in environments where</h4></a>
   requestors are not pre-registered (at least for authorization
   purposes, but possibly also for authentication purposes).

</p><p class="rfcparagraph">   This is necessary to be able to scale a AAA solution where there are
   many requestors.

</p><p class="rfcparagraph">	<a name="section-2.10.4"><h4>2.10.4   AAA protocols MUST be able to support a linkage between</h4></a>
   authorization and accounting mechanisms.

</p><p class="rfcparagraph">   Motherhood and apple-pie.
	<a name="section-2.10.5"><h4>2.10.5   AAA protocols MUST be able to support accountability</h4></a>
   (audit/non-repudiation) mechanisms.

</p><p class="rfcparagraph">   Sometimes, an authorization decision will be made where the requestor
   has not authenticated. In such cases, it must be possible that the
   authorization data used is linked to audit or other accountability
   mechanisms. Note that this requirement does not call for mandatory
   support for digital signatures, or other parts of a non-repudiation
   solution.

</p><p class="rfcparagraph">	<a name="section-2.11"><h3>2.11     Negotiation</h3></a>

	<a name="section-2.11.1"><h4>2.11.1   AAA protocols MUST support the ability to refer to sets of</h4></a>
   authorization packages in order to allow peers negotiate a common
   set.

</p><p class="rfcparagraph">   Given that peers may support different combinations of authorization
   attribute types and packages, the requirement states that protocol
   support is required to ensure that the peers use packages supported
   by both peers.

</p><p class="rfcparagraph">	<a name="section-2.11.2"><h4>2.11.2   It MUST be possible to negotiate authorization packages between</h4></a>
   AAA entities that are not in direct communication.

</p><p class="rfcparagraph">   This states that where, e.g. a broker is involved, the end AAA
   servers might still need to negotiate.

</p><p class="rfcparagraph">	<a name="section-2.11.3"><h4>2.11.3   Where negotiation fails to produce an acceptable common</h4></a>
   supported set then access MUST be denied.

</p><p class="rfcparagraph">   For example, a server cannot grant access if it cannot understand the
   attributes of the requestor.

</p><p class="rfcparagraph">	<a name="section-2.11.4"><h4>2.11.4   Where negotiation fails to produce an acceptable common</h4></a>
   supported set then it SHOULD be possible to generate an error
   indication to be sent to another AAA entity.

</p><p class="rfcparagraph">   If negotiation fails, then some administrator intervention is often
   required, and protocol support for this should be provided.

</p><p class="rfcparagraph">	<a name="section-2.11.5"><h4>2.11.5   It MUST be possible to pre-provision the result of a</h4></a>
   negotiation, but in such cases, the AAA protocol MUST include a
   confirmation of the "negotiation result".

</p><p class="rfcparagraph">   Even if the supported packages of a peer are configured, this must be
   confirmed before assuming both sides are similarly configured.
	<a name="section-2.11.6"><h4>2.11.6   For each application making use of a AAA protocol, there MUST be</h4></a>
   one inter-operable IETF standards-track specification of the
   authorization package types that are "mandatory to implement".

</p><p class="rfcparagraph">   This requirement assures that communicating peers can count on
   finding at least one IETF specified inter-operable AAA protocol
   dialect provided they are doing authorization for a common
   application specific problem domain. This does not preclude the
   negotiation of commonly understood but private AAA protocol
   authorization package types (e.g. vendor specific).

</p><p class="rfcparagraph">	<a name="section-2.11.7"><h4>2.11.7   It SHOULD also be possible to rank AAA negotiation options in</h4></a>
   order of preference.

</p><p class="rfcparagraph">   This states that, when negotiating, peers must be able to indicate
   preferences as well as capabilities.

</p><p class="rfcparagraph">	<a name="section-2.11.8"><h4>2.11.8   The negotiation mechanisms used by AAA protocols SHOULD NOT be</h4></a>
   vulnerable to a "bidding-down" attack.

</p><p class="rfcparagraph">   A "bidding-down" attack is where an attacker forces the negotiating
   parties to choose the "weakest" option available. This is analogous
   to forcing 40-bit encryption on a link. The requirement highlights
   that protocol support is needed to prevent such attacks, for example
   by including the negotiation messages as part of a later MAC
   calculation, if authentication has produced a shared secret.

</p><p class="rfcparagraph">	<a name="section-2.11.9"><h4>2.11.9   A peer MUST NOT send an attribute within an authorization</h4></a>
   package or attribute that was not agreed to by a prior successful
   negotiation. If this AAA protocol violation occurs, then it MUST be
   possible to send an error indication to the misbehaving peer, and
   generate an error indication to the network operator.

</p><p class="rfcparagraph">	<a name="section-2.11.10"><h4>2.11.10  A peer MUST declare all of the sets of the authorization</h4></a>
   packages that it understands in its initial negotiation bid message.

</p><p class="rfcparagraph">	<a name="section-3"><h2>3.  Security Considerations</h2></a>

   This document includes specific security requirements.

</p><p class="rfcparagraph">   This document does not state any detailed requirements for the
   interplay with authentication, accounting or accountability (audit).
   A AAA protocol, which meets all of the above requirements, may still
   leave vulnerabilities due to such interactions. Such issues must be
   considered as part of AAA protocol design.
	<a name="section-4"><h2>4.  References</h2></a>

   [FRMW]     Vollbrecht, J., Calhoun, P., Farrell, S., Gommans, L.,
              Gross, G., de Bruijn, B., de Laat, C., Holdrege, M. and D.
              Spence, "AAA Authorization Framework", RFC 2904, August
              2000.

</p><p class="rfcparagraph">   [RFC2026]  Bradner, S., "The Internet Standards Process -- Revision
              3", BCP 9, RFC 2026, October 1996.

</p><p class="rfcparagraph">   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

</p><p class="rfcparagraph">   [RFC2138]  Rigney, C., Rubens, A., Simpson, W. and S. Willens,
              "Remote Authentication Dial In User Service (RADIUS)", RFC
              2138, April 1997.

</p><p class="rfcparagraph">   [RFC2277]  Alvestrand, H., "IETF Policy on Character Sets and
              Languages", RFC 2277, January 1998.

</p><p class="rfcparagraph">   [SAMP]     Vollbrecht, J., Calhoun, P., Farrell, S., Gommans, L.,
              Gross, G., de Bruijn, B., de Laat, C., Holdrege, M. and D.
              Spence, "AAA Authorization Application Examples", RFC
              2905, August 2000.

</p><p class="rfcparagraph">Authors' Addresses

   Stephen Farrell
   Baltimore Technologies
   61/62 Fitzwilliam Lane
   Dublin 2,
   IRELAND

   Phone: +353-1-647-7300
   Fax: +353-1-647-7499
   EMail: stephen.farrell@baltimore.ie


   John R. Vollbrecht
   Interlink Networks, Inc.
   775 Technology Drive, Suite 200
   Ann Arbor, MI  48108
   USA

   Phone: +1 734 821 1205
   Fax:   +1 734 821 1235
   EMail: jrv@interlinknetworks.com
   Pat R. Calhoun
   Network and Security Research
   Center, Sun Labs
   Sun Microsystems, Inc.
   15 Network Circle
   Menlo Park, California, 94025
   USA

   Phone:  +1 650 786 7733
   Fax:  +1 650 786 6445
   EMail:  pcalhoun@eng.sun.com


   Leon Gommans
   Enterasys Networks EMEA
   Kerkplein 24
   2841 XM  Moordrecht
   The Netherlands

   Phone: +31 182 379279
   email: gommans@cabletron.com
          or at University of Utrecht:
          l.h.m.gommans@phys.uu.nl


   George M. Gross
   Lucent Technologies
   184 Liberty Corner Road, m.s.
   LC2N-D13
   Warren, NJ 07059
   USA

   Phone:  +1 908 580 4589
   Fax:    +1 908-580-4991
   EMail:  gmgross@lucent.com


   Betty de Bruijn
   Interpay Nederland B.V.
   Eendrachtlaan 315
   3526 LB Utrecht
   The Netherlands

   Phone: +31 30 2835104
   EMail: betty@euronet.nl
   Cees T.A.M. de Laat
   Physics and Astronomy dept.
   Utrecht University
   Pincetonplein 5,
   3584CC Utrecht
   Netherlands
   Phone: +31 30 2534585
   Phone: +31 30 2537555
   EMail: delaat@phys.uu.nl


   Matt Holdrege
   ipVerse
   223 Ximeno Ave.
   Long Beach, CA 90803

   EMail: matt@ipverse.com


   David W. Spence
   Interlink Networks, Inc.
   775 Technology Drive, Suite 200
   Ann Arbor, MI  48108
   USA

   Phone: +1 734 821 1203
   Fax:   +1 734 821 1235
   EMail: dspence@interlinknetworks.com
Full Copyright Statement

   Copyright (C) The Internet Society (2000).  All Rights Reserved.<br>

</p><p class="rfcparagraph">   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

</p><p class="rfcparagraph">   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assigns.

</p><p class="rfcparagraph">   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

</p><p class="rfcparagraph">Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

</p>

















Farrell, et al.              Informational                     [Page 23]


      </td>
      <td class=code>
        <div class='highlight'>
            <!--
            <b>Related Stack Overflow questions:</b>
            <ul>
                
            </ul>
            -->
        </div>
      </td>
    </tr>
  </table>
</div>
</body>