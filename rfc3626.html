<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <title></title>
  <link rel="stylesheet" href="rfc.css">
</head>
<body>
<div id='container'>
  <div id="background"></div>
  <table cellspacing=0 cellpadding=0>
  <thead>
    <tr>
      <th class=docs><h1></h1></th>
      <th class=code></th>
    </tr>
  </thead>
  <tbody>
    <tr id='section-'>
      <td class=docs>
        <p class="rfcparagraph"><p>Network Working Group                                    T. Clausen, Ed.<br>Request for Comments: 3626                               P. Jacquet, Ed.<br>Category: Experimental                           Project Hipercom, INRIA<br>                                                            October 2003<br><br></p>
                  <h1>
              Optimized Link State Routing Protocol (OLSR)</h1>
                  <h2>Status of this Memo</h2>

   This memo defines an Experimental Protocol for the Internet
   community.  It does not specify an Internet standard of any kind.
   Discussion and suggestions for improvement are requested.
   Distribution of this memo is unlimited.

</p><p class="rfcparagraph"><h2>Copyright Notice</h2>

   Copyright (C) The Internet Society (2003).  All Rights Reserved.<br>

</p><p class="rfcparagraph"><h2>Abstract</h2>

   This document describes the Optimized Link State Routing (OLSR)
   protocol for mobile ad hoc networks.  The protocol is an optimization
   of the classical link state algorithm tailored to the requirements of
   a mobile wireless LAN.  The key concept used in the protocol is that
   of multipoint relays (MPRs).  MPRs are selected nodes which forward
   broadcast messages during the flooding process.  This technique
   substantially reduces the message overhead as compared to a classical
   flooding mechanism, where every node retransmits each message when it
   receives the first copy of the message.  In OLSR, link state
   information is generated only by nodes elected as MPRs.  Thus, a
   second optimization is achieved by minimizing the number of control
   messages flooded in the network.  As a third optimization, an MPR
   node may chose to report only links between itself and its MPR
   selectors.  Hence, as contrary to the classic link state algorithm,
   partial link state information is distributed in the network.  This
   information is then used for route calculation.  OLSR provides
   optimal routes (in terms of number of hops).  The protocol is
   particularly suitable for large and dense networks as the technique
   of MPRs works well in this context.
<h2>Table of Contents</h2>
<a href="#section-1" class="">1. Introduction  . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.1" class="indent-1">1.1. OLSR Terminology.  . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.2" class="indent-1">1.2. Applicability. . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.3" class="indent-1">1.3. Protocol Overview  . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-1.4" class="indent-1">1.4. Multipoint Relays  . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-2" class="">2. Protocol Functioning  . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-2.1" class="indent-1">2.1. Core Functioning   . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-2.2" class="indent-1">2.2. Auxiliary Functioning  . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3" class="">3. Packet Format and Forwarding  . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.1" class="indent-1">3.1. Protocol and Port Number.  . . . . . . . . . . . . . . </a><br>
<a href="#section-3.2" class="indent-1">3.2. Main Address   . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.3" class="indent-1">3.3. Packet Format  . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.3.1" class="indent-2">3.3.1. Packet Header . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.3.2" class="indent-2">3.3.2. Message Header  . . . . . . . . . . . . . . . . </a><br>
<a href="#section-3.4" class="indent-1">3.4. Packet Processing and Message Flooding . . . . . . . . </a><br>
<a href="#section-3.4.1" class="indent-2">3.4.1. Default Forwarding Algorithm. . . . . . . . . . </a><br>
<a href="#section-3.4.2" class="indent-2">3.4.2. Considerations on Processing and Forwarding . . </a><br>
<a href="#section-3.5" class="indent-1">3.5. Message Emission and Jitter. . . . . . . . . . . . . . </a><br>
<a href="#section-4" class="">4. Information Repositories  . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.1" class="indent-1">4.1. Multiple Interface Association Information Base  . . . </a><br>
<a href="#section-4.2" class="indent-1">4.2. Link sensing: Local Link Information Base. . . . . . . </a><br>
<a href="#section-4.2.1" class="indent-2">4.2.1. Link Set. . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.3" class="indent-1">4.3. Neighbor Detection: Neighborhood Information Base. . . </a><br>
<a href="#section-4.3.1" class="indent-2">4.3.1. Neighbor Set. . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.3.2" class="indent-2">4.3.2. 2-hop Neighbor Set. . . . . . . . . . . . . . . </a><br>
<a href="#section-4.3.3" class="indent-2">4.3.3. MPR Set . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.3.4" class="indent-2">4.3.4. MPR Selector Set. . . . . . . . . . . . . . . . </a><br>
<a href="#section-4.4" class="indent-1">4.4. Topology Information Base  . . . . . . . . . . . . . . </a><br>
<a href="#section-5" class="">5. Main Addresses and Multiple Interfaces  . . . . . . . . . . </a><br>
<a href="#section-5.1" class="indent-1">5.1. MID Message Format . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-5.2" class="indent-1">5.2. MID Message Generation . . . . . . . . . . . . . . . . </a><br>
<a href="#section-5.3" class="indent-1">5.3. MID Message Forwarding . . . . . . . . . . . . . . . . </a><br>
<a href="#section-5.4" class="indent-1">5.4. MID Message Processing . . . . . . . . . . . . . . . . </a><br>
<a href="#section-5.5" class="indent-1">5.5. Resolving a Main Address from an Interface Address . . </a><br>
<a href="#section-6" class="">6. HELLO Message Format and Generation . . . . . . . . . . . . </a><br>
<a href="#section-6.1" class="indent-1">6.1. HELLO Message Format . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-6.1.1" class="indent-2">6.1.1. Link Code as Link Type and Neighbor Type. . . . </a><br>
<a href="#section-6.2" class="indent-1">6.2. HELLO Message Generation . . . . . . . . . . . . . . . </a><br>
<a href="#section-6.3" class="indent-1">6.3. HELLO Message Forwarding . . . . . . . . . . . . . . . </a><br>
<a href="#section-6.4" class="indent-1">6.4. HELLO Message Processing . . . . . . . . . . . . . . . </a><br>
<a href="#section-7" class="">7. Link Sensing  . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-7.1" class="indent-1">7.1. Populating the Link Set  . . . . . . . . . . . . . . . </a><br>
<a href="#section-7.1.1" class="indent-2">7.1.1. HELLO Message Processing  . . . . . . . . . . . </a><br>
<a href="#section-8" class="">8. Neighbor Detection  . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-8.1" class="indent-1">8.1. Populating the Neighbor Set . . . . . . . . . . . . . . </a><br>
<a href="#section-8.1.1" class="indent-2">8.1.1. HELLO Message Processing  . . . . . . . . . . . </a><br>
<a href="#section-8.2" class="indent-1">8.2. Populating the 2-hop Neighbor Set. . . . . . . . . . . </a><br>
<a href="#section-8.2.1" class="indent-2">8.2.1. HELLO Message Processing. . . . . . . . . . . . </a><br>
<a href="#section-8.3" class="indent-1">8.3. Populating the MPR set . . . . . . . . . . . . . . . . </a><br>
<a href="#section-8.3.1" class="indent-2">8.3.1. MPR Computation . . . . . . . . . . . . . . . . </a><br>
<a href="#section-8.4" class="indent-1">8.4. Populating the MPR Selector Set. . . . . . . . . . . . </a><br>
<a href="#section-8.4.1" class="indent-2">8.4.1. HELLO Message Processing. . . . . . . . . . . . </a><br>
<a href="#section-8.5" class="indent-1">8.5. Neighborhood and 2-hop Neighborhood Changes. . . . . . </a><br>
<a href="#section-9" class="">9. Topology Discovery  . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-9.1" class="indent-1">9.1. TC Message Format. . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-9.2" class="indent-1">9.2. Advertised Neighbor Set. . . . . . . . . . . . . . . . </a><br>
<a href="#section-9.3" class="indent-1">9.3. TC Message Generation. . . . . . . . . . . . . . . . . </a><br>
<a href="#section-9.4" class="indent-1">9.4. TC Message Forwarding. . . . . . . . . . . . . . . . . </a><br>
<a href="#section-9.5" class="indent-1">9.5. TC Message Processing. . . . . . . . . . . . . . . . . </a><br>
<a href="#section-10" class="">10. Routing Table Calculation . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-11" class="">11. Node Configuration. . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-11.1" class="indent-1">11.1. Address Assignment. . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-11.2" class="indent-1">11.2. Routing Configuration . . . . . . . . . . . . . . . . </a><br>
<a href="#section-11.3" class="indent-1">11.3. Data Packet Forwarding. . . . . . . . . . . . . . . . </a><br>
<a href="#section-12" class="">12. Non OLSR Interfaces . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-12.1" class="indent-1">12.1. HNA Message Format. . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-12.2" class="indent-1">12.2. Host and Network Association Information Base . . . . </a><br>
<a href="#section-12.3" class="indent-1">12.3. HNA Message Generation. . . . . . . . . . . . . . . . </a><br>
<a href="#section-12.4" class="indent-1">12.4. HNA Message Forwarding. . . . . . . . . . . . . . . . </a><br>
<a href="#section-12.5" class="indent-1">12.5. HNA Message Processing. . . . . . . . . . . . . . . . </a><br>
<a href="#section-12.6" class="indent-1">12.6. Routing Table Calculation . . . . . . . . . . . . . . </a><br>
<a href="#section-12.7" class="indent-1">12.7. Interoperability Considerations . . . . . . . . . . . </a><br>
<a href="#section-13" class="">13. Link Layer Notification . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-13.1" class="indent-1">13.1. Interoperability Considerations . . . . . . . . . . . </a><br>
<a href="#section-14" class="">14. Link Hysteresis . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-14.1" class="indent-1">14.1. Local Link Set  . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-14.2" class="indent-1">14.2. Hello Message Generation  . . . . . . . . . . . . . . </a><br>
<a href="#section-14.3" class="indent-1">14.3. Hysteresis Strategy . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-14.4" class="indent-1">14.4. Interoperability Considerations . . . . . . . . . . . </a><br>
<a href="#section-15" class="">15. Redundant Topology Information. . . . . . . . . . . . . . . </a><br>
<a href="#section-15.1" class="indent-1">15.1. TC_REDUNDANCY Parameter . . . . . . . . . . . . . . . </a><br>
<a href="#section-15.2" class="indent-1">15.2. Interoperability Considerations . . . . . . . . . . . </a><br>
<a href="#section-16" class="">16. MPR Redundancy. . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-16.1" class="indent-1">16.1. MPR_COVERAGE Parameter. . . . . . . . . . . . . . . . </a><br>
<a href="#section-16.2" class="indent-1">16.2. MPR Computation . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-16.3" class="indent-1">16.3. Interoperability Considerations . . . . . . . . . . . </a><br>
<a href="#section-17" class="">17. IPv6 Considerations . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18" class="">18. Proposed Values for Constants . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.1" class="indent-1">18.1. Setting emission interval and holding times . . . . . </a><br>
<a href="#section-18.2" class="indent-1">18.2. Emission Interval . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.3" class="indent-1">18.3. Holding time  . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.4" class="indent-1">18.4. Message Types . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.5" class="indent-1">18.5. Link Types. . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.6" class="indent-1">18.6. Neighbor Types  . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.7" class="indent-1">18.7. Link Hysteresis . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.8" class="indent-1">18.8. Willingness . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-18.9" class="indent-1">18.9. Misc. Constants . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-19" class="">19. Sequence Numbers. . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-20" class="">20. Security Considerations . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-20.1" class="indent-1">20.1. Confidentiality . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-20.2" class="indent-1">20.2. Integrity . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-20.3" class="indent-1">20.3. Interaction with External Routing Domains . . . . . . </a><br>
<a href="#section-20.4" class="indent-1">20.4. Node Identity . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-21" class="">21. Flow and congestion control . . . . . . . . . . . . . . . . </a><br>
<a href="#section-22" class="">22. IANA Considerations . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-23" class="">23. Acknowledgments . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-24" class="">24. Contributors. . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-25" class="">25. References. . . . . . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-26" class="">26. Authors' Addresses. . . . . . . . . . . . . . . . . . . . . </a><br>
<a href="#section-27" class="">27. Full Copyright Statement. . . . . . . . . . . . . . . . . . </a><br>

	<a name="section-1"><h2>1.   Introduction</h2></a>

   The Optimized Link State Routing Protocol (OLSR) is developed for
   mobile ad hoc networks.  It operates as a table driven, proactive
   protocol, i.e., exchanges topology information with other nodes of
   the network regularly.  Each node selects a set of its neighbor nodes
   as "multipoint relays" (MPR).  In OLSR, only nodes, selected as such
   MPRs, are responsible for forwarding control traffic, intended for
   diffusion into the entire network.  MPRs provide an efficient
   mechanism for flooding control traffic by reducing the number of
   transmissions required.

</p><p class="rfcparagraph">   Nodes, selected as MPRs, also have a special responsibility when
   declaring link state information in the network.  Indeed, the only
   requirement for OLSR to provide shortest path routes to all
   destinations is that MPR nodes declare link-state information for
   their MPR selectors.  Additional available link-state information may
   be utilized, e.g., for redundancy.

</p><p class="rfcparagraph">   Nodes which have been selected as multipoint relays by some neighbor
   node(s) announce this information periodically in their control
   messages.  Thereby a node announces to the network, that it has
   reachability to the nodes which have selected it as an MPR.  In route
   calculation, the MPRs are used to form the route from a given node to
   any destination in the network.  Furthermore, the protocol uses the
   MPRs to facilitate efficient flooding of control messages in the
   network.

</p><p class="rfcparagraph">   A node selects MPRs from among its one hop neighbors with
   "symmetric", i.e., bi-directional, linkages.  Therefore, selecting
   the route through MPRs automatically avoids the problems associated
   with data packet transfer over uni-directional links (such as the
   problem of not getting link-layer acknowledgments for data packets at
   each hop, for link-layers employing this technique for unicast
   traffic).

</p><p class="rfcparagraph">   OLSR is developed to work independently from other protocols.
   Likewise, OLSR makes no assumptions about the underlying link-layer.

</p><p class="rfcparagraph">   OLSR inherits the concept of forwarding and relaying from HIPERLAN (a
   MAC layer protocol) which is standardized by ETSI [3].  The protocol
   is developed in the IPANEMA project (part of the Euclid program) and
   in the PRIMA project (part of the RNRT program).

</p><p class="rfcparagraph">	<a name="section-1.1"><h3>1.1   OLSR Terminology</h3></a>

   The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in RFC2119 [5].

</p><p class="rfcparagraph">   Additionally, this document uses the following terminology:

</p><p class="rfcparagraph">      node

         A MANET router which implements the Optimized Link State
         Routing protocol as specified in this document.

</p><p class="rfcparagraph">      OLSR interface

         A network device participating in a MANET running OLSR.  A node
         may have several OLSR interfaces, each interface assigned an
         unique IP address.

</p><p class="rfcparagraph">      non OLSR interface

         A network device, not participating in a MANET running OLSR.  A
         node may have several non OLSR interfaces (wireless and/or
         wired).  Routing information from these interfaces MAY be
         injected into the OLSR routing domain.

</p><p class="rfcparagraph">      single OLSR interface node

         A node which has a single OLSR interface, participating in an
         OLSR routing domain.

</p><p class="rfcparagraph">      multiple OLSR interface node

         A node which has multiple OLSR interfaces, participating in an
         OLSR routing domain.
      main address

         The main address of a node, which will be used in OLSR control
         traffic as the "originator address" of all messages emitted by
         this node.  It is the address of one of the OLSR interfaces of
         the node.

</p><p class="rfcparagraph">         A single OLSR interface node MUST use the address of its only
         OLSR interface as the main address.

</p><p class="rfcparagraph">         A multiple OLSR interface node MUST choose one of its OLSR
         interface addresses as its "main address" (equivalent of
         "router ID" or "node identifier").  It is of no importance
         which address is chosen, however a node SHOULD always use the
         same address as its main address.

</p><p class="rfcparagraph">      neighbor node

         A node X is a neighbor node of node Y if node Y can hear node X
         (i.e., a link exists between an OLSR interface on node X and an
         OLSR interface on Y).

</p><p class="rfcparagraph">      2-hop neighbor

         A node heard by a neighbor.

</p><p class="rfcparagraph">      strict 2-hop neighbor

         a 2-hop neighbor which is not the node itself or a neighbor of
         the node, and in addition is a neighbor of a neighbor, with
         willingness different from WILL_NEVER, of the node.

</p><p class="rfcparagraph">      multipoint relay (MPR)

         A node which is selected by its 1-hop neighbor, node X, to
         "re-transmit" all the broadcast messages that it receives from
         X, provided that the message is not a duplicate, and that the
         time to live field of the message is greater than one.

</p><p class="rfcparagraph">      multipoint relay selector (MPR selector, MS)

         A node which has selected its 1-hop neighbor, node X, as its
         multipoint relay, will be called a multipoint relay selector of
         node X.
      link

         A link is a pair of OLSR interfaces (from two different nodes)
         susceptible to hear one another (i.e., one may be able to
         receive traffic from the other).  A node is said to have a link
         to another node when one of its interface has a link to one of
         the interfaces of the other node.

</p><p class="rfcparagraph">      symmetric link

         A verified bi-directional link between two OLSR interfaces.

</p><p class="rfcparagraph">      asymmetric link

         A link between two OLSR interfaces, verified in only one
         direction.

</p><p class="rfcparagraph">      symmetric 1-hop neighborhood

         The symmetric 1-hop neighborhood of any node X is the set of
         nodes which have at least one symmetric link to X.

</p><p class="rfcparagraph">      symmetric 2-hop neighborhood

         The symmetric 2-hop neighborhood of X is the set of nodes,
         excluding X itself, which have a symmetric link to the
         symmetric 1-hop neighborhood of X.

</p><p class="rfcparagraph">      symmetric strict 2-hop neighborhood

         The symmetric strict 2-hop neighborhood of X is the set of
         nodes, excluding X itself and its neighbors, which have a
         symmetric link to some symmetric 1-hop neighbor, with
         willingness different of WILL_NEVER, of X.

</p><p class="rfcparagraph">	<a name="section-1.2"><h3>1.2   Applicability</h3></a>

   OLSR is a proactive routing protocol for mobile ad-hoc networks
   (MANETs) [1], [2].  It is well suited to large and dense mobile
   networks, as the optimization achieved using the MPRs works well in
   this context.  The larger and more dense a network, the more
   optimization can be achieved as compared to the classic link state
   algorithm.  OLSR uses hop-by-hop routing, i.e., each node uses its
   local information to route packets.

</p><p class="rfcparagraph">   OLSR is well suited for networks, where the traffic is random and
   sporadic between a larger set of nodes rather than being almost
   exclusively between a small specific set of nodes.  As a proactive
   protocol, OLSR is also suitable for scenarios where the communicating
   pairs change over time: no additional control traffic is generated in
   this situation since routes are maintained for all known destinations
   at all times.

</p><p class="rfcparagraph">	<a name="section-1.3"><h3>1.3   Protocol Overview</h3></a>

   OLSR is a proactive routing protocol for mobile ad hoc networks.  The
   protocol inherits the stability of a link state algorithm and has the
   advantage of having routes immediately available when needed due to
   its proactive nature.  OLSR is an optimization over the classical
   link state protocol, tailored for mobile ad hoc networks.

</p><p class="rfcparagraph">   OLSR minimizes the overhead from flooding of control traffic by using
   only selected nodes, called MPRs, to retransmit control messages.
   This technique significantly reduces the number of retransmissions
   required to flood a message to all nodes in the network.  Secondly,
   OLSR requires only partial link state to be flooded in order to
   provide shortest path routes.  The minimal set of link state
   information required is, that all nodes, selected as MPRs, MUST
   declare the links to their MPR selectors.  Additional topological
   information, if present, MAY be utilized e.g., for redundancy
   purposes.

</p><p class="rfcparagraph">   OLSR MAY optimize the reactivity to topological changes by reducing
   the maximum time interval for periodic control message transmission.
   Furthermore, as OLSR continuously maintains routes to all
   destinations in the network, the protocol is beneficial for traffic
   patterns where a large subset of nodes are communicating with another
   large subset of nodes, and where the [source, destination] pairs are
   changing over time.  The protocol is particularly suited for large
   and dense networks, as the optimization done using MPRs works well in
   this context.  The larger and more dense a network, the more
   optimization can be achieved as compared to the classic link state
   algorithm.

</p><p class="rfcparagraph">   OLSR is designed to work in a completely distributed manner and does
   not depend on any central entity.  The protocol does NOT REQUIRE
   reliable transmission of control messages: each node sends control
   messages periodically, and can therefore sustain a reasonable loss of
   some such messages.  Such losses occur frequently in radio networks
   due to collisions or other transmission problems.

</p><p class="rfcparagraph">   Also, OLSR does not require sequenced delivery of messages.  Each
   control message contains a sequence number which is incremented for
   each message.  Thus the recipient of a control message can, if
   required, easily identify which information is more recent - even if
   messages have been re-ordered while in transmission.
   Furthermore, OLSR provides support for protocol extensions such as
   sleep mode operation, multicast-routing etc.  Such extensions may be
   introduced as additions to the protocol without breaking backwards
   compatibility with earlier versions.

</p><p class="rfcparagraph">   OLSR does not require any changes to the format of IP packets.  Thus
   any existing IP stack can be used as is: the protocol only interacts
   with routing table management.

</p><p class="rfcparagraph">	<a name="section-1.4"><h3>1.4   Multipoint Relays</h3></a>

   The idea of multipoint relays is to minimize the overhead of flooding
   messages in the network by reducing redundant retransmissions in the
   same region.  Each node in the network selects a set of nodes in its
   symmetric 1-hop neighborhood which may retransmit its messages.  This
   set of selected neighbor nodes is called the "Multipoint Relay" (MPR)
   set of that node.  The neighbors of node N which are *NOT* in its MPR
   set, receive and process broadcast messages but do not retransmit
   broadcast messages received from node N.

</p><p class="rfcparagraph">   Each node selects its MPR set from among its 1-hop symmetric
   neighbors.  This set is selected such that it covers (in terms of
   radio range) all symmetric strict 2-hop nodes.  The MPR set of N,
   denoted as MPR(N), is then an arbitrary subset of the symmetric 1-hop
   neighborhood of N which satisfies the following condition: every node
   in the symmetric strict 2-hop neighborhood of N must have a symmetric
   link towards MPR(N).  The smaller a MPR set, the less control traffic
   overhead results from the routing protocol.  [2] gives an analysis
   and example of MPR selection algorithms.

</p><p class="rfcparagraph">   Each node maintains information about the set of neighbors that have
   selected it as MPR.  This set is called the "Multipoint Relay
   Selector set" (MPR selector set) of a node.  A node obtains this
   information from periodic HELLO messages received from the neighbors.

</p><p class="rfcparagraph">   A broadcast message, intended to be diffused in the whole network,
   coming from any of the MPR selectors of node N is assumed to be
   retransmitted by node N, if N has not received it yet.  This set can
   change over time (i.e., when a node selects another MPR-set) and is
   indicated by the selector nodes in their HELLO messages.

</p><p class="rfcparagraph">	<a name="section-2"><h2>2.   Protocol Functioning</h2></a>

   This section outlines the overall protocol functioning.

</p><p class="rfcparagraph">   OLSR is modularized into a "core" of functionality, which is always
   required for the protocol to operate, and a set of auxiliary
   functions.
   The core specifies, in its own right, a protocol able to provide
   routing in a stand-alone MANET.

</p><p class="rfcparagraph">   Each auxiliary function provides additional functionality, which may
   be applicable in specific scenarios, e.g., in case a node is
   providing connectivity between the MANET and another routing domain.

</p><p class="rfcparagraph">   All auxiliary functions are compatible, to the extent where any
   (sub)set of auxiliary functions may be implemented with the core.
   Furthermore, the protocol allows heterogeneous nodes, i.e., nodes
   which implement different subsets of the auxiliary functions, to
   coexist in the network.

</p><p class="rfcparagraph">   The purpose of dividing the functioning of OLSR into a core
   functionality and a set of auxiliary functions is to provide a simple
   and easy-to-comprehend protocol, and to provide a way of only adding
   complexity where specific additional functionality is required.

</p><p class="rfcparagraph">	<a name="section-2.1"><h3>2.1   Core Functioning</h3></a>

   The core functionality of OLSR specifies the behavior of a node,
   equipped with OLSR interfaces participating in the MANET and running
   OLSR as routing protocol.  This includes a universal specification of
   OLSR protocol messages and their transmission through the network, as
   well as link sensing, topology diffusion and route calculation.

</p><p class="rfcparagraph">   Specifically, the core is made up from the following components:

</p><p class="rfcparagraph">      Packet Format and Forwarding

         A universal specification of the packet format and an optimized
         flooding mechanism serves as the transport mechanism for all
         OLSR control traffic.

</p><p class="rfcparagraph">      Link Sensing

         Link Sensing is accomplished through periodic emission of HELLO
         messages over the interfaces through which connectivity is
         checked.  A separate HELLO message is generated for each
         interface and emitted in correspondence with the provisions in
         section 7.

</p><p class="rfcparagraph">         Resulting from Link Sensing is a local link set, describing
         links between "local interfaces" and "remote interfaces" -
         i.e., interfaces on neighbor nodes.
         If sufficient information is provided by the link-layer, this
         may be utilized to populate the local link set instead of HELLO
         message exchange.

</p><p class="rfcparagraph">      Neighbor detection

         Given a network with only single interface nodes, a node may
         deduct the neighbor set directly from the information exchanged
         as part of link sensing: the "main address" of a single
         interface node is, by definition, the address of the only
         interface on that node.

</p><p class="rfcparagraph">         In a network with multiple interface nodes, additional
         information is required in order to map interface addresses to
         main addresses (and, thereby, to nodes).  This additional
         information is acquired through multiple interface declaration
         (MID) messages, described in section 5.

</p><p class="rfcparagraph">      MPR Selection and MPR Signaling

         The objective of MPR selection is for a node to select a subset
         of its neighbors such that a broadcast message, retransmitted
         by these selected neighbors, will be received by all nodes 2
         hops away.  The MPR set of a node is computed such that it, for
         each interface, satisfies this condition.  The information
         required to perform this calculation is acquired through the
         periodic exchange of HELLO messages, as described in section 6.
         MPR selection procedures are detailed in section 8.3.

</p><p class="rfcparagraph">         MPR signaling is provided in correspondence with the provisions
         in the section 6.

</p><p class="rfcparagraph">      Topology Control Message Diffusion

         Topology Control messages are diffused with the purpose of
         providing each node in the network with sufficient link-state
         information to allow route calculation.  Topology Control
         messages are diffused in correspondence with the provisions in
         section 9.

</p><p class="rfcparagraph">      Route Calculation

         Given the link state information acquired through periodic
         message exchange, as well as the interface configuration of the
         nodes, the routing table for each node can be computed.  This
         is detailed in section 10.
   The key notion for these mechanisms is the MPR relationship.

</p><p class="rfcparagraph">   The following table specifies the component of the core functionality
   of OLSR, as well as their relations to this document.

</p><p class="rfcparagraph">          Feature                      |  Section
         ------------------------------<pre>+--------------
          Packet format and forwarding |     3
          Information repositories     |     4
          Main addr and multiple if.   |     5
          Hello messages               |     6
          Link sensing                 |     7
          Neighbor detection           |     8
          Topology discovery           |     9
          Routing table computation    |    10
          Node configuration           |    11

	<a name="section-2.2"><h3>2.2   Auxiliary Functioning</h3></a>

   In addition to the core functioning of OLSR, there are situations
   where additional functionality is desired.  This includes situations
   where a node has multiple interfaces, some of which participate in
   another routing domain, where the programming interface to the
   networking hardware provides additional information in form of link
   layer notifications and where it is desired to provide redundant
   topological information to the network on expense of protocol
   overhead.

</p><p class="rfcparagraph">   The following table specifies auxiliary functions and their relation
   to this document.

</p><p class="rfcparagraph">          Feature                      |  Section
         ------------------------------+--------------
          Non-OLSR interfaces          |    12
          Link-layer notifications     |    13
          Advanced link sensing        |    14
          Redundant topology           |    15
          Redundant MPR flooding       |    16


   The interpretation of the above table is as follows: if the feature
   listed is required, it SHOULD be provided as specified in the
   corresponding section.
	<a name="section-3"><h2>3.   Packet Format and Forwarding</h2></a>

   OLSR communicates using a unified packet format for all data related
   to the protocol.  The purpose of this is to facilitate extensibility
   of the protocol without breaking backwards compatibility.  This also
   provides an easy way of piggybacking different "types" of information
   into a single transmission, and thus for a given implementation to
   optimize towards utilizing the maximal frame-size, provided by the
   network.  These packets are embedded in UDP datagrams for
   transmission over the network.  The present document is presented
   with IPv4 addresses.  Considerations regarding IPv6 are given in
   section 17.

</p><p class="rfcparagraph">   Each packet encapsulates one or more messages.  The messages share a
   common header format, which enables nodes to correctly accept and (if
   applicable) retransmit messages of an unknown type.

</p><p class="rfcparagraph">   Messages can be flooded onto the entire network, or flooding can be
   limited to nodes within a diameter (in terms of number of hops) from
   the originator of the message.  Thus transmitting a message to the
   neighborhood of a node is just a special case of flooding.  When
   flooding any control message, duplicate retransmissions will be
   eliminated locally (i.e., each node maintains a duplicate set to
   prevent transmitting the same OLSR control message twice) and
   minimized in the entire network through the usage of MPRs as
   described in later sections.

</p><p class="rfcparagraph">   Furthermore, a node can examine the header of a message to obtain
   information on the distance (in terms of number of hops) to the
   originator of the message.  This feature may be useful in situations
   where, e.g., the time information from a received control messages
   stored in a node depends on the distance to the originator.

</p><p class="rfcparagraph">	<a name="section-3.1"><h3>3.1   Protocol and Port Number</h3></a>

   Packets in OLSR are communicated using UDP.  Port 698 has been
   assigned by IANA for exclusive usage by the OLSR protocol.

</p><p class="rfcparagraph">	<a name="section-3.2"><h3>3.2   Main Address</h3></a>

   For a node with one interface, the main address of a node, as defined
   in "OLSR Terminology", MUST be set to the address of that interface.
	<a name="section-3.3"><h3>3.3   Packet Format</h3></a>

   The basic layout of any packet in OLSR is as follows (omitting IP and
   UDP headers):

</p><p class="rfcparagraph">       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |         Packet Length         |    Packet Sequence Number     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Message Type |     Vtime     |         Message Size          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      Originator Address                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Time To Live |   Hop Count   |    Message Sequence Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      :                            MESSAGE                            :
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Message Type |     Vtime     |         Message Size          |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                      Originator Address                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |  Time To Live |   Hop Count   |    Message Sequence Number    |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                                                               |
      :                            MESSAGE                            :
      |                                                               |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                                                               :
               (etc.)

	<a name="section-3.3.1"><h4>3.3.1   Packet Header</h4></a>

      Packet Length

         The length (in bytes) of the packet

      Packet Sequence Number

         The Packet Sequence Number (PSN) MUST be incremented by one
         each time a new OLSR packet is transmitted.  "Wrap-around" is
         handled as described in section 19.  A separate Packet Sequence
         Number is maintained for each interface such that packets
         transmitted over an interface are sequentially enumerated.
   The IP address of the interface over which a packet was transmitted
   is obtainable from the IP header of the packet.

</p><p class="rfcparagraph">   If the packet contains no messages (i.e., the Packet Length is less
   than or equal to the size of the packet header), the packet MUST
   silently be discarded.

</p><p class="rfcparagraph">   For IPv4 addresses, this implies that packets, where the Packet
   Length < 16 MUST silently be discarded.

</p><p class="rfcparagraph">	<a name="section-3.3.2"><h4>3.3.2   Message Header</h4></a>

      Message Type

         This field indicates which type of message is to be found in
         the "MESSAGE" part.  Message types in the range of 0-127 are
         reserved for messages in this document and in possible
         extensions.

</p><p class="rfcparagraph">      Vtime

         This field indicates for how long time after reception a node
         MUST consider the information contained in the message as
         valid, unless a more recent update to the information is
         received.  The validity time is represented by its mantissa
         (four highest bits of Vtime field) and by its exponent (four
         lowest bits of Vtime field).  In other words:

</p><p class="rfcparagraph">              validity time = C*(1+a/16)* 2^b  [in seconds]

         where a is the integer represented by the four highest bits of
         Vtime field and b the integer represented by the four lowest
         bits of Vtime field.  The proposed value of the scaling factor
         C is specified in section 18.

</p><p class="rfcparagraph">      Message Size

         This gives the size of this message, counted in bytes and
         measured from the beginning of the "Message Type" field and
         until the beginning of the next "Message Type" field (or - if
         there are no following messages - until the end of the packet).

</p><p class="rfcparagraph">      Originator Address

         This field contains the main address of the node, which has
         originally generated this message.  This field SHOULD NOT be
         confused with the source address from the IP header, which is
         changed each time to the address of the intermediate interface
         which is re-transmitting this message.  The Originator Address
         field MUST *NEVER* be changed in retransmissions.

</p><p class="rfcparagraph">      Time To Live

         This field contains the maximum number of hops a message will
         be transmitted.  Before a message is retransmitted, the Time To
         Live MUST be decremented by 1.  When a node receives a message
         with a Time To Live equal to 0 or 1, the message MUST NOT be
         retransmitted under any circumstances.  Normally, a node would
         not receive a message with a TTL of zero.

</p><p class="rfcparagraph">         Thus, by setting this field, the originator of a message can
         limit the flooding radius.

</p><p class="rfcparagraph">      Hop Count

         This field contains the number of hops a message has attained.
         Before a message is retransmitted, the Hop Count MUST be
         incremented by 1.

</p><p class="rfcparagraph">         Initially, this is set to '0' by the originator of the message.

</p><p class="rfcparagraph">      Message Sequence Number

         While generating a message, the "originator" node will assign a
         unique identification number to each message.  This number is
         inserted into the Sequence Number field of the message.  The
         sequence number is increased by 1 (one) for each message
         originating from the node.  "Wrap-around" is handled as
         described in section 19.  Message sequence numbers are used to
         ensure that a given message is not retransmitted more than once
         by any node.

</p><p class="rfcparagraph">	<a name="section-3.4"><h3>3.4   Packet Processing and Message Flooding</h3></a>

   Upon receiving a basic packet, a node examines each of the "message
   headers".  Based on the value of the "Message Type" field, the node
   can determine the fate of the message.  A node may receive the same
   message several times.  Thus, to avoid re-processing of some messages
   which were already received and processed, each node maintains a
   Duplicate Set.  In this set, the node records information about the
   most recently received messages where duplicate processing of a
   message is to be avoided.  For such a message, a node records a
   "Duplicate Tuple" (D_addr, D_seq_num, D_retransmitted, D_iface_list,
   D_time), where D_addr is the originator address of the message,
   D_seq_num is the message sequence number of the message,
   D_retransmitted is a boolean indicating whether the message has been
   already retransmitted, D_iface_list is a list of the addresses of the
   interfaces on which the message has been received and D_time
   specifies the time at which a tuple expires and *MUST* be removed.

</p><p class="rfcparagraph">   In a node, the set of Duplicate Tuples are denoted the "Duplicate
   set".

</p><p class="rfcparagraph">   In this section, the term "Originator Address" will be used for the
   main address of the node which sent the message.  The term "Sender
   Interface Address" will be used for the sender address (given in the
   IP header of the packet containing the message) of the interface
   which sent the message.  The term "Receiving Interface Address" will
   be used for the address of the interface of the node which received
   the message.

</p><p class="rfcparagraph">   Thus, upon receiving a basic packet, a node MUST perform the
   following tasks for each encapsulated message:

</p><p class="rfcparagraph">     1    If the packet contains no messages (i.e., the Packet Length is
          less than or equal to the size of the packet header), the
          packet MUST silently be discarded.

</p><p class="rfcparagraph">          For IPv4 addresses, this implies that packets, where the
          Packet Length < 16 MUST silently be discarded.

</p><p class="rfcparagraph">     2    If the time to live of the message is less than or equal to
          '0' (zero), or if the message was sent by the receiving node
          (i.e., the Originator Address of the message is the main
          address of the receiving node): the message MUST silently be
          dropped.

</p><p class="rfcparagraph">     3    Processing condition:

</p><p class="rfcparagraph">          3.1  if there exists a tuple in the duplicate set, where:

</p><p class="rfcparagraph">                             D_addr    == Originator Address, AND

                             D_seq_num == Message Sequence Number

               then the message has already been completely processed
               and MUST not be processed again.

</p><p class="rfcparagraph">          3.2  Otherwise, if the node implements the Message Type of the
               message, the message MUST be processed according to the
               specifications for the message type.
     4    Forwarding condition:

</p><p class="rfcparagraph">          4.1  if there exists a tuple in the duplicate set, where:

</p><p class="rfcparagraph">                                D_addr    == Originator Address, AND

                                D_seq_num == Message Sequence Number,
                    AND

                                the receiving interface (address) is
                                in D_iface_list

               then the message has already been considered for
               forwarding and SHOULD NOT be retransmitted again.

</p><p class="rfcparagraph">          4.2  Otherwise:

</p><p class="rfcparagraph">               4.2.1
                    If the node implements the Message Type of the
                    message, the message MUST be considered for
                    forwarding according to the specifications for
                    the message type.

</p><p class="rfcparagraph">               4.2.2
                    Otherwise, if the node does not implement the
                    Message Type of the message, the message SHOULD
                    be processed according to the default
                    forwarding algorithm described below.

</p><p class="rfcparagraph">	<a name="section-3.4.1"><h4>3.4.1   Default Forwarding Algorithm</h4></a>

   The default forwarding algorithm is the following:

</p><p class="rfcparagraph">     1    If the sender interface address of the message is not detected
          to be in the symmetric 1-hop neighborhood of the node, the
          forwarding algorithm MUST silently stop here (and the message
          MUST NOT be forwarded).

</p><p class="rfcparagraph">     2    If there exists a tuple in the duplicate set where:

</p><p class="rfcparagraph">               D_addr    == Originator Address

               D_seq_num == Message Sequence Number

          Then the message will be further considered for forwarding if
          and only if:

</p><p class="rfcparagraph">               D_retransmitted is false, AND
               the (address of the) interface which received the message
               is not included among the addresses in D_iface_list

     3    Otherwise, if such an entry doesn't exist, the message is
          further considered for forwarding.

</p><p class="rfcparagraph">   If after those steps, the message is not considered for forwarding,
   then the processing of this section stops (i.e., steps 4 to 8 are
   ignored), otherwise, if it is still considered for forwarding then
   the following algorithm is used:

</p><p class="rfcparagraph">     4    If the sender interface address is an interface address of a
          MPR selector of this node and if the time to live of the
          message is greater than '1', the message MUST be retransmitted
          (as described later in steps 6 to 8).

</p><p class="rfcparagraph">     5    If an entry in the duplicate set exists, with same Originator
          Address, and same Message Sequence Number, the entry is
          updated as follows:

</p><p class="rfcparagraph">               D_time    = current time + DUP_HOLD_TIME.

</p><p class="rfcparagraph">               The receiving interface (address) is added to
               D_iface_list.

</p><p class="rfcparagraph">               D_retransmitted is set to true if and only if the message
               will be retransmitted according to step 4.

</p><p class="rfcparagraph">          Otherwise an entry in the duplicate set is recorded with:

</p><p class="rfcparagraph">               D_addr    = Originator Address

               D_seq_num = Message Sequence Number

               D_time    = current time + DUP_HOLD_TIME.

</p><p class="rfcparagraph">               D_iface_list contains the receiving interface address.

</p><p class="rfcparagraph">               D_retransmitted is set to true if and only if the message
               will be retransmitted according to step 4.

</p><p class="rfcparagraph">   If, and only if, according to step 4, the message must be
   retransmitted then:

</p><p class="rfcparagraph">     6    The TTL of the message is reduced by one.

</p><p class="rfcparagraph">     7    The hop-count of the message is increased by one
     8    The message is broadcast on all interfaces (Notice: The
          remaining fields of the message header SHOULD be left
          unmodified.)

	<a name="section-3.4.2"><h4>3.4.2   Considerations on Processing and Forwarding</h4></a>

   It should be noted that processing and forwarding messages are two
   different actions, conditioned by different rules.  Processing
   relates to using the content of the messages, while forwarding is
   related to retransmitting the same message for other nodes of the
   network.

</p><p class="rfcparagraph">   Notice that this specification includes a description for both the
   forwarding and the processing of each known message type.  Messages
   with known message types MUST *NOT* be forwarded "blindly" by this
   algorithm.  Forwarding (and setting the correct message header in the
   forwarded, known, message) is the responsibility of the algorithm
   specifying how the message is to be handled and, if necessary,
   retransmitted.  This enables a message type to be specified such that
   the message can be modified while in transit (e.g., to reflect the
   route the message has taken).  It also enables bypassing of the MPR
   flooding mechanism if for some reason classical flooding of a message
   type is required, the algorithm which specifies how such messages
   should be handled will simply rebroadcast the message, regardless of
   MPRs.

</p><p class="rfcparagraph">   By defining a set of message types, which MUST be recognized by all
   implementations of OLSR, it will be possible to extend the protocol
   through introduction of additional message types, while still being
   able to maintain compatibility with older implementations.  The
   REQUIRED message types for the core functionality of OLSR are:

</p><p class="rfcparagraph">     -    HELLO-messages, performing the task of link sensing, neighbor
          detection and MPR signaling,

     -    TC-messages, performing the task of topology declaration
          (advertisement of link states).

</p><p class="rfcparagraph">     -    MID-messages, performing the task of declaring the presence of
          multiple interfaces on a node.

</p><p class="rfcparagraph">   Other message types include those specified in later sections, as
   well as possible future extensions such as messages enabling power
   conservation / sleep mode, multicast routing, support for
   unidirectional links, auto-configuration/address assignment etc.
	<a name="section-3.5"><h3>3.5   Message Emission and Jitter</h3></a>

   As a basic implementation requirement, synchronization of control
   messages SHOULD be avoided.  As a consequence, OLSR control messages
   SHOULD be emitted such that they avoid synchronization.

</p><p class="rfcparagraph">   Emission of control traffic from neighboring nodes may, for various
   reasons (mainly timer interactions with packet processing), become
   synchronized such that several neighbor nodes attempt to transmit
   control traffic simultaneously.  Depending on the nature of the
   underlying link-layer, this may or may not lead to collisions and
   hence message loss - possibly loss of several subsequent messages of
   the same type.

</p><p class="rfcparagraph">   To avoid such synchronizations, the following simple strategy for
   emitting control messages is proposed.  A node SHOULD add an amount
   of jitter to the interval at which messages are generated.  The
   jitter must be a random value for each message generated.  Thus, for
   a node utilizing jitter:

</p><p class="rfcparagraph">        Actual message interval = MESSAGE_INTERVAL - jitter

   Where jitter is a value, randomly selected from the interval
   [0,MAXJITTER] and MESSAGE_INTERVAL is the value of the message
   interval specified for the message being emitted (e.g.,
   HELLO_INTERVAL for HELLO messages, TC_INTERVAL for TC-messages etc.).

</p><p class="rfcparagraph">   Jitter SHOULD also be introduced when forwarding messages.  The
   following simple strategy may be adopted: when a message is to be
   forwarded by a node, it should be kept in the node during a short
   period of time :

</p><p class="rfcparagraph">           Keep message period = jitter

   Where jitter is a random value in [0,MAXJITTER].

</p><p class="rfcparagraph">   Notice that when the node sends a control message, the opportunity to
   piggyback other messages (before their keeping period is expired) may
   be taken to reduce the number of packet transmissions.

</p><p class="rfcparagraph">   Notice, that a minimal rate of control messages is imposed.  A node
   MAY send control messages at a higher rate, if beneficial for a
   specific deployment.
	<a name="section-4"><h2>4.   Information Repositories</h2></a>

   Through the exchange of OLSR control messages, each node accumulates
   information about the network.  This information is stored according
   to the descriptions in this section.

</p><p class="rfcparagraph">	<a name="section-4.1"><h3>4.1   Multiple Interface Association Information Base</h3></a>

   For each destination in the network, "Interface Association Tuples"
   (I_iface_addr, I_main_addr, I_time) are recorded.  I_iface_addr is an
   interface address of a node, I_main_addr is the main address of this
   node.  I_time specifies the time at which this tuple expires and
   *MUST* be removed.

</p><p class="rfcparagraph">   In a node, the set of Interface Association Tuples is denoted the
   "Interface Association Set".

</p><p class="rfcparagraph">	<a name="section-4.2"><h3>4.2   Link Sensing: Local Link Information Base</h3></a>

   The local link information base stores information about links to
   neighbors.

</p><p class="rfcparagraph">	<a name="section-4.2.1"><h4>4.2.1   Link Set</h4></a>

   A node records a set of "Link Tuples" (L_local_iface_addr,
   L_neighbor_iface_addr, L_SYM_time, L_ASYM_time, L_time).
   L_local_iface_addr is the interface address of the local node (i.e.,
   one endpoint of the link), L_neighbor_iface_addr is the interface
   address of the neighbor node (i.e., the other endpoint of the link),
   L_SYM_time is the time until which the link is considered symmetric,
   L_ASYM_time is the time until which the neighbor interface is
   considered heard, and L_time specifies the time at which this record
   expires and *MUST* be removed.  When L_SYM_time and L_ASYM_time are
   expired, the link is considered lost.

</p><p class="rfcparagraph">   This information is used when declaring the neighbor interfaces in
   the HELLO messages.

</p><p class="rfcparagraph">   L_SYM_time is used to decide the Link Type declared for the neighbor
   interface.  If L_SYM_time is not expired, the link MUST be declared
   symmetric.  If L_SYM_time is expired, the link MUST be declared
   asymmetric.  If both L_SYM_time and L_ASYM_time are expired, the link
   MUST be declared lost.

</p><p class="rfcparagraph">   In a node, the set of Link Tuples are denoted the "Link Set".
	<a name="section-4.3"><h3>4.3   Neighbor Detection: Neighborhood Information Base</h3></a>

   The neighborhood information base stores information about neighbors,
   2-hop neighbors, MPRs and MPR selectors.

</p><p class="rfcparagraph">	<a name="section-4.3.1"><h4>4.3.1   Neighbor Set</h4></a>

   A node records a set of "neighbor tuples" (N_neighbor_main_addr,
   N_status, N_willingness), describing neighbors.  N_neighbor_main_addr
   is the main address of a neighbor, N_status specifies if the node is
   NOT_SYM or SYM.  N_willingness in an integer between 0 and 7, and
   specifies the node's willingness to carry traffic on behalf of other
   nodes.

</p><p class="rfcparagraph">	<a name="section-4.3.2"><h4>4.3.2   2-hop Neighbor Set</h4></a>

   A node records a set of "2-hop tuples" (N_neighbor_main_addr,
   N_2hop_addr, N_time), describing symmetric (and, since MPR links by
   definition are also symmetric, thereby also MPR) links between its
   neighbors and the symmetric 2-hop neighborhood.  N_neighbor_main_addr
   is the main address of a neighbor, N_2hop_addr is the main address of
   a 2-hop neighbor with a symmetric link to N_neighbor_main_addr, and
   N_time specifies the time at which the tuple expires and *MUST* be
   removed.

</p><p class="rfcparagraph">   In a node, the set of 2-hop tuples are denoted the "2-hop Neighbor
   Set".

</p><p class="rfcparagraph">	<a name="section-4.3.3"><h4>4.3.3   MPR Set</h4></a>

   A node maintains a set of neighbors which are selected as MPR.  Their
   main addresses are listed in the MPR Set.

</p><p class="rfcparagraph">	<a name="section-4.3.4"><h4>4.3.4   MPR Selector Set</h4></a>

   A node records a set of MPR-selector tuples (MS_main_addr, MS_time),
   describing the neighbors which have selected this node as a MPR.
   MS_main_addr is the main address of a node, which has selected this
   node as MPR.  MS_time specifies the time at which the tuple expires
   and *MUST* be removed.

</p><p class="rfcparagraph">   In a node, the set of MPR-selector tuples are denoted the "MPR
   Selector Set".
	<a name="section-4.4"><h3>4.4   Topology Information Base</h3></a>

   Each node in the network maintains topology information about the
   network.  This information is acquired from TC-messages and is used
   for routing table calculations.

</p><p class="rfcparagraph">   Thus, for each destination in the network, at least one "Topology
   Tuple" (T_dest_addr, T_last_addr, T_seq, T_time) is recorded.
   T_dest_addr is the main address of a node, which may be reached in
   one hop from the node with the main address T_last_addr.  Typically,
   T_last_addr is a MPR of T_dest_addr.  T_seq is a sequence number, and
   T_time specifies the time at which this tuple expires and *MUST* be
   removed.

</p><p class="rfcparagraph">   In a node, the set of Topology Tuples are denoted the "Topology Set".

</p><p class="rfcparagraph">	<a name="section-5"><h2>5.   Main Addresses and Multiple Interfaces</h2></a>

   For single OLSR interface nodes, the relationship between an OLSR
   interface address and the corresponding main address is trivial: the
   main address is the OLSR interface address.  For multiple OLSR
   interface nodes, the relationship between OLSR interface addresses
   and main addresses is defined through the exchange of Multiple
   Interface Declaration (MID) messages.  This section describes how MID
   messages are exchanged and processed.

</p><p class="rfcparagraph">   Each node with multiple interfaces MUST announce, periodically,
   information describing its interface configuration to other nodes in
   the network.  This is accomplished through flooding a Multiple
   Interface Declaration message to all nodes in the network through the
   MPR flooding mechanism.

</p><p class="rfcparagraph">   Each node in the network maintains interface information about the
   other nodes in the network.  This information acquired from MID
   messages, emitted by nodes with multiple interfaces participating in
   the MANET, and is used for routing table calculations.

</p><p class="rfcparagraph">   Specifically, multiple interface declaration associates multiple
   interfaces to a node (and to a main address) through populating the
   multiple interface association base in each node.
	<a name="section-5.1"><h3>5.1   MID Message Format</h3></a>

   The proposed format of a MID message is as follows:

</p><p class="rfcparagraph">       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    OLSR Interface Address                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    OLSR Interface Address                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ...                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   This is sent as the data-portion of the general packet format
   described in section 3.4, with the "Message Type" set to MID_MESSAGE.
   The time to live SHOULD be set to 255 (maximum value) to diffuse the
   message into the entire network and Vtime set accordingly to the
   value of MID_HOLD_TIME, as specified in section 18.3.

</p><p class="rfcparagraph">     OLSR Interface Address

          This field contains the address of an OLSR interface of the
          node, excluding the nodes main address (which already
          indicated in the originator address).

</p><p class="rfcparagraph">   All interface addresses other than the main address of the originator
   node are put in the MID message.  If the maximum allowed message size
   (as imposed by the network) is reached while there are still
   interface addresses which have not been inserted into the MIDmessage,
   more MID messages are generated until the entire interface addresses
   set has been sent.

</p><p class="rfcparagraph">	<a name="section-5.2"><h3>5.2   MID Message Generation</h3></a>

   A MID message is sent by a node in the network to declare its
   multiple interfaces (if any).  I.e., the MID message contains the
   list of interface addresses which are associated to its main address.
   The list of addresses can be partial in each MID message (e.g., due
   to message size limitations, imposed by the network), but parsing of
   all MID messages describing the interface set from a node MUST be
   complete within a certain refreshing period (MID_INTERVAL).  The
   information diffused in the network by these MID messages will help
   each node to calculate its routing table.  A node which has only a
   single interface address participating in the MANET (i.e., running
   OLSR), MUST NOT generate any MID message.
   A node with several interfaces, where only one is participating in
   the MANET and running OLSR (e.g., a node is connected to a wired
   network as well as to a MANET) MUST NOT generate any MID messages.

</p><p class="rfcparagraph">   A node with several interfaces, where more than one is participating
   in the MANET and running OLSR MUST generate MID messages as
   specified.

</p><p class="rfcparagraph">	<a name="section-5.3"><h3>5.3   MID Message Forwarding</h3></a>

   MID messages are broadcast and retransmitted by the MPRs in order to
   diffuse the messages in the entire network.  The "default forwarding
   algorithm" (described in section 3.4) MUST be used for forwarding of
   MID messages.

</p><p class="rfcparagraph">	<a name="section-5.4"><h3>5.4   MID Message Processing</h3></a>

   The tuples in the multiple interface association set are recorded
   with the information that is exchanged through MID messages.

</p><p class="rfcparagraph">   Upon receiving a MID message, the "validity time" MUST be computed
   from the Vtime field of the message header (as described in section
   3.3.2).  The Multiple Interface Association Information Base SHOULD
   then be updated as follows:

</p><p class="rfcparagraph">     1    If the sender interface (NB: not originator) of this message
          is not in the symmetric 1-hop neighborhood of this node, the
          message MUST be discarded.

</p><p class="rfcparagraph">     2    For each interface address listed in the MID message:

</p><p class="rfcparagraph">          2.1  If there exist some tuple in the interface association
               set where:

</p><p class="rfcparagraph">                    I_iface_addr == interface address, AND

                    I_main_addr  == originator address,

               then the holding time of that tuple is set to:

</p><p class="rfcparagraph">                    I_time       = current time + validity time.

</p><p class="rfcparagraph">          2.2  Otherwise, a new tuple is recorded in the interface
               association set where:

</p><p class="rfcparagraph">                    I_iface_addr = interface address,

                    I_main_addr  = originator address,
                    I_time       = current time + validity time.

</p><p class="rfcparagraph">	<a name="section-5.5"><h3>5.5   Resolving a Main Address from an Interface Address</h3></a>

   In general, the only part of OLSR requiring use of "interface
   addresses" is link sensing.  The remaining parts of OLSR operate on
   nodes, uniquely identified by their "main addresses" (effectively,
   the main address of a node is its "node id" - which for convenience
   corresponds to the address of one of its interfaces).  In a network
   with only single interface nodes, the main address of a node will, by
   definition, be equal to the interface address of the node.  In
   networks with multiple interface nodes operating within a common OLSR
   area, it is required to be able to map any interface address to the
   corresponding main address.

</p><p class="rfcparagraph">   The exchange of MID messages provides a way in which interface
   information is acquired by nodes in the network.  This permits
   identification of a node's "main address", given one of its interface
   addresses.

</p><p class="rfcparagraph">   Given an interface address:

</p><p class="rfcparagraph">     1    if there exists some tuple in the interface association set
          where:

</p><p class="rfcparagraph">               I_iface_addr == interface address

          then the result of the main address search is the originator
          address I_main_addr of the tuple.

</p><p class="rfcparagraph">     2    Otherwise, the result of the main address search is the
          interface address itself.

</p><p class="rfcparagraph">	<a name="section-6"><h2>6.   HELLO Message Format and Generation</h2></a>

   A common mechanism is employed for populating the local link
   information base and the neighborhood information base, namely
   periodic exchange of HELLO messages.  Thus this section describes the
   general HELLO message mechanism, followed by a description of link
   sensing and topology detection, respectively.

</p><p class="rfcparagraph">	<a name="section-6.1"><h3>6.1   HELLO Message Format</h3></a>

   To accommodate for link sensing, neighborhood detection and MPR
   selection signalling, as well as to accommodate for future
   extensions, an approach similar to the overall packet format is
   taken.  Thus the proposed format of a HELLO message is as follows:
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1

      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |          Reserved             |     Htime     |  Willingness  |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Link Code   |   Reserved    |       Link Message Size       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                  Neighbor Interface Address                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                  Neighbor Interface Address                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                             .  .  .                           :
      :                                                               :
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Link Code   |   Reserved    |       Link Message Size       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                  Neighbor Interface Address                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                  Neighbor Interface Address                   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      :                                                               :
      :                                       :
   (etc.)

   This is sent as the data-portion of the general packet format
   described in section 3.4, with the "Message Type" set to
   HELLO_MESSAGE, the TTL field set to 1 (one) and Vtime set accordingly
   to the value of NEIGHB_HOLD_TIME, specified in section 18.3.

</p><p class="rfcparagraph">      Reserved

         This field must be set to "0000000000000" to be in compliance
         with this specification.

</p><p class="rfcparagraph">      HTime

         This field specifies the HELLO emission interval used by the
         node on this particular interface, i.e., the time before the
         transmission of the next HELLO (this information may be used in
         advanced link sensing, see section 14).  The HELLO emission
         interval is represented by its mantissa (four highest bits of
         Htime field) and by its exponent (four lowest bits of Htime
         field).  In other words:

</p><p class="rfcparagraph">              HELLO emission interval=C*(1+a/16)*2^b  [in seconds]
         where a is the integer represented by the four highest bits of
         Htime field and b the integer represented by the four lowest
         bits of Htime field.  The proposed value of the scaling factor
         C is specified in section 18.

</p><p class="rfcparagraph">      Willingness

         This field specifies the willingness of a node to carry and
         forward traffic for other nodes.

</p><p class="rfcparagraph">         A node with willingness WILL_NEVER (see section 18.8, for
         willingness constants) MUST never be selected as MPR by any
         node.  A node with willingness WILL_ALWAYS MUST always be
         selected as MPR.  By default, a node SHOULD advertise a
         willingness of WILL_DEFAULT.

</p><p class="rfcparagraph">      Link Code

         This field specifies information about the link between the
         interface of the sender and the following list of neighbor
         interfaces.  It also specifies information about the status of
         the neighbor.

</p><p class="rfcparagraph">         Link codes, not known by a node, are silently discarded.

</p><p class="rfcparagraph">      Link Message Size

         The size of the link message, counted in bytes and measured
         from the beginning of the "Link Code" field and until the next
         "Link Code" field (or - if there are no more link types - the
         end of the message).

</p><p class="rfcparagraph">      Neighbor Interface Address

         The address of an interface of a neighbor node.

</p><p class="rfcparagraph">	<a name="section-6.1.1"><h4>6.1.1   Link Code as Link Type and Neighbor Type</h4></a>

   This document only specifies processing of Link Codes < 16.

</p><p class="rfcparagraph">   If the Link Code value is less than or equal to 15, then it MUST be
   interpreted as holding two different fields, of two bits each:

</p><p class="rfcparagraph">          7       6       5       4       3       2       1       0
      +-------+-------+-------+-------+-------+-------+-------+-------+
      |   0   |   0   |   0   |   0   | Neighbor Type |   Link Type   |
      +-------+-------+-------+-------+-------+-------+-------+-------+
</pre>

   The following four "Link Types" are REQUIRED by OLSR:

</p><p class="rfcparagraph">     -    UNSPEC_LINK - indicating that no specific information about
          the links is given.

</p><p class="rfcparagraph">     -    ASYM_LINK - indicating that the links are asymmetric (i.e.,
          the neighbor interface is "heard").

</p><p class="rfcparagraph">     -    SYM_LINK - indicating that the links are symmetric with the
          interface.

</p><p class="rfcparagraph">     -    LOST_LINK - indicating that the links have been lost.

</p><p class="rfcparagraph">   The following three "Neighbor Types" are REQUIRED by OLSR:

</p><p class="rfcparagraph">     -    SYM_NEIGH - indicating that the neighbors have at least one
          symmetrical link with this node.

</p><p class="rfcparagraph">     -    MPR_NEIGH - indicating that the neighbors have at least one
          symmetrical link AND have been selected as MPR by the sender.

</p><p class="rfcparagraph">     -    NOT_NEIGH - indicating that the nodes are either no longer or
          have not yet become symmetric neighbors.

</p><p class="rfcparagraph">   Note that an implementation should be careful in confusing neither
   Link Type with Neighbor Type nor the constants (confusing SYM_NEIGH
   with SYM_LINK for instance).

</p><p class="rfcparagraph">   A link code advertising:

</p><p class="rfcparagraph">          Link Type     == SYM_LINK AND

          Neighbor Type == NOT_NEIGH

   is invalid, and any links advertised as such MUST be silently
   discarded without any processing.

</p><p class="rfcparagraph">   Likewise a Neighbor Type field advertising a numerical value which is
   not one of the constants SYM_NEIGH, MPR_NEIGH, NOT_NEIGH, is invalid,
   and any links advertised as such MUST be silently discarded without
   any processing.

</p><p class="rfcparagraph">	<a name="section-6.2"><h3>6.2   HELLO Message Generation</h3></a>

   This involves transmitting the Link Set, the Neighbor Set and the MPR
   Set.  In principle, a HELLO message serves three independent tasks:

</p><p class="rfcparagraph">     -    link sensing
     -    neighbor detection

     -    MPR selection signaling

   Three tasks are all are based on periodic information exchange within
   a nodes neighborhood, and serve the common purpose of "local topology
   discovery".  A HELLO message is therefore generated based on the
   information stored in the Local Link Set, the Neighbor Set and the
   MPR Set from the local link information base.

</p><p class="rfcparagraph">   A node must perform link sensing on each interface, in order to
   detect links between the interface and neighbor interfaces.
   Furthermore, a node must advertise its entire symmetric 1-hop
   neighborhood on each interface in order to perform neighbor
   detection.  Hence, for a given interface, a HELLO message will
   contain a list of links on that interface (with associated link
   types), as well as a list of the entire neighborhood (with an
   associated neighbor types).

</p><p class="rfcparagraph">   The Vtime field is set such that it corresponds to the value of the
   node's NEIGHB_HOLD_TIME parameter.  The Htime field is set such that
   it corresponds to the value of the node's HELLO_INTERVAL parameter
   (see section 18.3).

</p><p class="rfcparagraph">   The Willingness field is set such that it corresponds to the node's
   willingness to forward traffic on behalf of other nodes (see section
   18.8).  A node MUST advertise the same willingness on all interfaces.

</p><p class="rfcparagraph">   The lists of addresses declared in a HELLO message is a list of
   neighbor interface addresses computed as follows:

</p><p class="rfcparagraph">   For each tuple in the Link Set, where L_local_iface_addr is the
   interface where the HELLO is to be transmitted, and where L_time >=
   current time (i.e., not expired), L_neighbor_iface_addr is advertised
   with:

</p><p class="rfcparagraph">     1    The Link Type set according to the following:

</p><p class="rfcparagraph">          1.1  if L_SYM_time >= current time (not expired)

                    Link Type = SYM_LINK

          1.2  Otherwise, if L_ASYM_time >= current time (not expired)
               AND

                             L_SYM_time  <  current time (expired)

                    Link Type = ASYM_LINK
          1.3  Otherwise, if L_ASYM_time < current time (expired) AND

                             L_SYM_time  < current time (expired)

                    Link Type = LOST_LINK

     2    The Neighbor Type is set according to the following:

</p><p class="rfcparagraph">          2.1  If the main address, corresponding to
               L_neighbor_iface_addr, is included in the MPR set:

</p><p class="rfcparagraph">                    Neighbor Type = MPR_NEIGH

          2.2  Otherwise, if the main address, corresponding to
               L_neighbor_iface_addr, is included in the neighbor set:

</p><p class="rfcparagraph">               2.2.1
                    if N_status == SYM

                         Neighbor Type = SYM_NEIGH

               2.2.2
                    Otherwise, if N_status == NOT_SYM
                         Neighbor Type = NOT_NEIGH

   For each tuple in the Neighbor Set, for which no
   L_neighbor_iface_addr from an associated link tuple has been
   advertised by the previous algorithm,  N_neighbor_main_addr is
   advertised with:

</p><p class="rfcparagraph">     - Link Type = UNSPEC_LINK,

     - Neighbor Type set as described in step 2 above

   For a node with a single OLSR interface, the main address is simply
   the address of the OLSR interface, i.e., for a node with a single
   OLSR interface the main address, corresponding to
   L_neighbor_iface_addr is simply L_neighbor_iface_addr.

</p><p class="rfcparagraph">   A HELLO message can be partial (e.g., due to message size
   limitations, imposed by the network), the rule being the following,
   on each interface: each link and each neighbor node MUST be cited at
   least once within a predetermined refreshing period,
   REFRESH_INTERVAL.  To keep track of fast connectivity changes, a
   HELLO message must be sent at least every HELLO_INTERVAL period,
   smaller than or equal to REFRESH_INTERVAL.
   Notice that for limiting the impact from loss of control messages, it
   is desirable that a message (plus the generic packet header) can fit
   into a single MAC frame.

</p><p class="rfcparagraph">	<a name="section-6.3"><h3>6.3   HELLO Message Forwarding</h3></a>

   Each HELLO message generated is broadcast by the node on one
   interface to its neighbors (i.e. the interface for which the HELLO
   was generated).  HELLO messages MUST never be forwarded.

</p><p class="rfcparagraph">	<a name="section-6.4"><h3>6.4   HELLO Message Processing</h3></a>

   A node processes incoming HELLO messages for the purpose of
   conducting link sensing (detailed in section 7), neighbor detection
   and MPR selector set population (detailed in section 8)

	<a name="section-7"><h2>7.   Link Sensing</h2></a>

   Link sensing populates the local link information base.  Link sensing
   is exclusively concerned with OLSR interface addresses and the
   ability to exchange packets between such OLSR interfaces.

</p><p class="rfcparagraph">   The mechanism for link sensing is the periodic exchange of HELLO
   messages.

</p><p class="rfcparagraph">	<a name="section-7.1"><h3>7.1   Populating the Link Set</h3></a>

   The Link Set is populated with information on links to neighbor
   nodes.  The process of populating this set is denoted "link sensing"
   and is performed using HELLO message exchange, updating a local link
   information base in each node.

</p><p class="rfcparagraph">   Each node should detect the links between itself and neighbor nodes.
   Uncertainties over radio propagation may make some links
   unidirectional.  Consequently, all links MUST be checked in both
   directions in order to be considered valid.

</p><p class="rfcparagraph">   A "link" is described by a pair of interfaces: a local and a remote
   interface.

</p><p class="rfcparagraph">   For the purpose of link sensing, each neighbor node (more
   specifically, the link to each neighbor) has an associated status of
   either "symmetric" or "asymmetric".  "Symmetric" indicates, that the
   link to that neighbor node has been verified to be bi-directional,
   i.e., it is possible to transmit data in both directions.
   "Asymmetric" indicates that HELLO messages from the node have been
   heard (i.e., communication from the neighbor node is possible),
   however it is not confirmed that this node is also able to receive
   messages (i.e., communication to the neighbor node is not confirmed).

</p><p class="rfcparagraph">   The information, acquired through and used by the link sensing, is
   accumulated in the link set.

</p><p class="rfcparagraph">	<a name="section-7.1.1"><h4>7.1.1   HELLO Message Processing</h4></a>

   The "Originator Address" of a HELLO message is the main address of
   the node, which has emitted the message.

</p><p class="rfcparagraph">   Upon receiving a HELLO message, a node SHOULD update its Link Set.
   Notice, that a HELLO message MUST neither be forwarded nor be
   recorded in the duplicate set.

</p><p class="rfcparagraph">   Upon receiving a HELLO message, the "validity time" MUST be computed
   from the Vtime field of the message header (see section 3.3.2).
   Then, the Link Set SHOULD be updated as follows:

</p><p class="rfcparagraph">     1    Upon receiving a HELLO message, if there exists no link tuple
          with

               L_neighbor_iface_addr == Source Address

          a new tuple is created with

               L_neighbor_iface_addr = Source Address

               L_local_iface_addr    = Address of the interface
                                       which received the
                                       HELLO message

               L_SYM_time            = current time - 1 (expired)

               L_time                = current time + validity time

     2    The tuple (existing or new) with:

</p><p class="rfcparagraph">               L_neighbor_iface_addr == Source Address

          is then modified as follows:

</p><p class="rfcparagraph">          2.1  L_ASYM_time = current time + validity time;

</p><p class="rfcparagraph">          2.2  if the node finds the address of the interface which
               received the HELLO message among the addresses listed in
               the link message then the tuple is modified as follows:
               2.2.1
                    if Link Type is equal to LOST_LINK then

                         L_SYM_time = current time - 1 (i.e., expired)

               2.2.2
                    else if Link Type is equal to SYM_LINK or ASYM_LINK
                    then

                         L_SYM_time = current time + validity time,

                         L_time     = L_SYM_time + NEIGHB_HOLD_TIME

          2.3  L_time = max(L_time, L_ASYM_time)

   The above rule for setting L_time is the following: a link losing its
   symmetry SHOULD still be advertised during at least the duration of
   the "validity time" advertised in the generated HELLO.  This allows
   neighbors to detect the link breakage.

</p><p class="rfcparagraph">	<a name="section-8"><h2>8.   Neighbor Detection</h2></a>

   Neighbor detection populates the neighborhood information base and
   concerns itself with nodes and node main addresses.  The relationship
   between OLSR interface addresses and main addresses is described in
   section 5.

</p><p class="rfcparagraph">   The mechanism for neighbor detection is the periodic exchange of
   HELLO messages.

</p><p class="rfcparagraph">	<a name="section-8.1"><h3>8.1   Populating the Neighbor Set</h3></a>

   A node maintains a set of neighbor tuples, based on the link tuples.
   This information is updated according to changes in the Link Set.

</p><p class="rfcparagraph">   The Link Set keeps the information about the links, while the
   Neighbor Set keeps the information about the neighbors.  There is a
   clear association between those two sets, since a node is a neighbor
   of another node if and only if there is at least one link between the
   two nodes.

</p><p class="rfcparagraph">   In any case, the formal correspondence between links and neighbors is
   defined as follows:

</p><p class="rfcparagraph">          The "associated neighbor tuple" of a link tuple, is, if it
          exists, the neighbor tuple where:
               N_neighbor_main_addr == main address of
                                       L_neighbor_iface_addr

          The "associated link tuples" of a neighbor tuple, are all the
          link tuples, where:

</p><p class="rfcparagraph">               N_neighbor_main_addr == main address of
                                       L_neighbor_iface_addr

   The Neighbor Set MUST be populated by maintaining the proper
   correspondence between link tuples and associated neighbor tuples, as
   follows:

</p><p class="rfcparagraph">     Creation

          Each time a link appears, that is, each time a link tuple is
          created, the associated neighbor tuple MUST be created, if it
          doesn't already exist, with the following values:

</p><p class="rfcparagraph">               N_neighbor_main_addr = main address of
                                      L_neighbor_iface_addr
                                      (from the link tuple)

          In any case, the N_status MUST then be computed as described
          in the next step

     Update

          Each time a link changes, that is, each time the information
          of a link tuple is modified, the node MUST ensure that the
          N_status of the associated neighbor tuple respects the
          property:

</p><p class="rfcparagraph">               If the neighbor has any associated link tuple which
               indicates a symmetric link (i.e., with L_SYM_time >=
               current time), then

                    N_status is set to SYM

               else N_status is set to NOT_SYM

     Removal

          Each time a link is deleted, that is, each time a link tuple
          is removed, the associated neighbor tuple MUST be removed if
          it has no longer any associated link tuples.
   These rules ensure that there is exactly one associated neighbor
   tuple for a link tuple, and that every neighbor tuple has at least
   one associated link tuple.

</p><p class="rfcparagraph">	<a name="section-8.1.1"><h4>8.1.1   HELLO Message Processing</h4></a>

   The "Originator Address" of a HELLO message is the main address of
   the node, which has emitted the message.  Likewise, the "willingness"
   MUST be computed from the Willingness field of the HELLO message (see
   section 6.1).

</p><p class="rfcparagraph">   Upon receiving a HELLO message, a node SHOULD first update its Link
   Set as described before.  It SHOULD then update its Neighbor Set as
   follows:

</p><p class="rfcparagraph">     -    if the Originator Address is the N_neighbor_main_addr from a
          neighbor tuple included in the Neighbor Set:

</p><p class="rfcparagraph">               then, the neighbor tuple SHOULD be updated as follows:

</p><p class="rfcparagraph">               N_willingness = willingness from the HELLO message

	<a name="section-8.2"><h3>8.2   Populating the 2-hop Neighbor Set</h3></a>

   The 2-hop neighbor set describes the set of nodes which have a
   symmetric link to a symmetric neighbor.  This information set is
   maintained through periodic exchange of HELLO messages as described
   in this section.

</p><p class="rfcparagraph">	<a name="section-8.2.1"><h4>8.2.1   HELLO Message Processing</h4></a>

   The "Originator Address" of a HELLO message is the main address of
   the node, which has emitted the message.

</p><p class="rfcparagraph">   Upon receiving a HELLO message from a symmetric neighbor, a node
   SHOULD update its 2-hop Neighbor Set.  Notice, that a HELLO message
   MUST neither be forwarded nor be recorded in the duplicate set.

</p><p class="rfcparagraph">   Upon receiving a HELLO message, the "validity time" MUST be computed
   from the Vtime field of the message header (see section 3.3.2).

</p><p class="rfcparagraph">   If the Originator Address is the main address of a
   L_neighbor_iface_addr from a link tuple included in the Link Set with

          L_SYM_time >= current time (not expired)

   (in other words: if the Originator Address is a symmetric neighbor)
   then the 2-hop Neighbor Set SHOULD be updated as follows:
     1    for each address (henceforth: 2-hop neighbor address), listed
          in the HELLO message with Neighbor Type equal to SYM_NEIGH or
          MPR_NEIGH:

</p><p class="rfcparagraph">          1.1  if the main address of the 2-hop neighbor address = main
               address of the receiving node:

</p><p class="rfcparagraph">                    silently discard the 2-hop neighbor address.

</p><p class="rfcparagraph">               (in other words: a node is not its own 2-hop neighbor).

</p><p class="rfcparagraph">          1.2  Otherwise, a 2-hop tuple is created with:

</p><p class="rfcparagraph">                    N_neighbor_main_addr =  Originator Address;

</p><p class="rfcparagraph">                    N_2hop_addr          =  main address of the
                                            2-hop neighbor;

</p><p class="rfcparagraph">                    N_time               =  current time
                                            + validity time.

</p><p class="rfcparagraph">
               This tuple may replace an older similar tuple with same
               N_neighbor_main_addr and N_2hop_addr values.

</p><p class="rfcparagraph">     2    For each 2-hop node listed in the HELLO message with Neighbor
          Type equal to NOT_NEIGH, all 2-hop tuples where:

</p><p class="rfcparagraph">               N_neighbor_main_addr == Originator Address AND

               N_2hop_addr          == main address of the
                                       2-hop neighbor

          are deleted.

</p><p class="rfcparagraph">	<a name="section-8.3"><h3>8.3   Populating the MPR set</h3></a>

   MPRs are used to flood control messages from a node into the network
   while reducing the number of retransmissions that will occur in a
   region.  Thus, the concept of MPR is an optimization of a classical
   flooding mechanism.

</p><p class="rfcparagraph">   Each node in the network selects, independently, its own set of MPRs
   among its symmetric 1-hop neighborhood.  The symmetric links with
   MPRs are advertised with Link Type MPR_NEIGH instead of SYM_NEIGH in
   HELLO messages.
   The MPR set MUST be calculated by a node in such a way that it,
   through the neighbors in the MPR-set, can reach all symmetric strict
   2-hop neighbors.  (Notice that a node, a, which is a direct neighbor
   of another node, b, is not also a strict 2-hop neighbor of node b).
   This means that the union of the symmetric 1-hop neighborhoods of the
   MPR nodes contains the symmetric strict 2-hop neighborhood.  MPR set
   recalculation should occur when changes are detected in the symmetric
   neighborhood or in the symmetric strict 2-hop neighborhood.

</p><p class="rfcparagraph">   MPRs are computed per interface, the union of the MPR sets of each
   interface make up the MPR set for the node.

</p><p class="rfcparagraph">   While it is not essential that the MPR set is minimal, it is
   essential that all strict 2-hop neighbors can be reached through the
   selected MPR nodes.  A node SHOULD select an MPR set such that any
   strict 2-hop neighbor is covered by at least one MPR node.  Keeping
   the MPR set small ensures that the overhead of the protocol is kept
   at a minimum.

</p><p class="rfcparagraph">   The MPR set can coincide with the entire symmetric neighbor set.
   This could be the case at network initialization (and will correspond
   to classic link-state routing).

</p><p class="rfcparagraph">	<a name="section-8.3.1"><h4>8.3.1   MPR Computation</h4></a>

   The following specifies a proposed heuristic for selection of MPRs.
   It constructs an MPR-set that enables a node to reach any node in the
   symmetrical strict 2-hop neighborhood through relaying by one MPR
   node with willingness different from WILL_NEVER.  The heuristic MUST
   be applied per interface, I.  The MPR set for a node is the union of
   the MPR sets found for each interface.  The following terminology
   will be used in describing the heuristics:

</p><p class="rfcparagraph">       neighbor of an interface

              a node is a "neighbor of an interface" if the interface
              (on the local node) has a link to any one interface of
              the neighbor node.

</p><p class="rfcparagraph">       2-hop neighbors reachable from an interface

              the list of 2-hop neighbors of the node that can be
              reached from neighbors of this interface.
       MPR set of an interface

              a (sub)set of the neighbors of an interface with a
              willingness different from WILL_NEVER, selected such that
              through these selected nodes, all strict 2-hop neighbors
              reachable from that interface are reachable.

</p><p class="rfcparagraph">       N:
              N is the subset of neighbors of the node, which are
              neighbor of the interface I.

</p><p class="rfcparagraph">       N2:
              The set of 2-hop neighbors reachable from the interface
              I, excluding:

</p><p class="rfcparagraph">               (i)   the nodes only reachable by members of N with
                     willingness WILL_NEVER

               (ii)  the node performing the computation

               (iii) all the symmetric neighbors: the nodes for which
                     there exists a symmetric link to this node on some
                     interface.

</p><p class="rfcparagraph">    D(y):
              The degree of a 1-hop neighbor node y (where y is a
              member of N), is defined as the number of symmetric
              neighbors of node y, EXCLUDING all the members of N and
              EXCLUDING the node performing the computation.

</p><p class="rfcparagraph">   The proposed heuristic is as follows:

</p><p class="rfcparagraph">     1    Start with an MPR set made of all members of N with
          N_willingness equal to WILL_ALWAYS

     2    Calculate D(y), where y is a member of N, for all nodes in N.

</p><p class="rfcparagraph">     3    Add to the MPR set those nodes in N, which are the *only*
          nodes to provide reachability to a node in N2.  For example,
          if node b in N2 can be reached only through a symmetric link
          to node a in N, then add node a to the MPR set.  Remove the
          nodes from N2 which are now covered by a node in the MPR set.

</p><p class="rfcparagraph">     4    While there exist nodes in N2 which are not covered by at
          least one node in the MPR set:
          4.1  For each node in N, calculate the reachability, i.e., the
               number of nodes in N2 which are not yet covered by at
               least one node in the MPR set, and which are reachable
               through this 1-hop neighbor;

</p><p class="rfcparagraph">          4.2  Select as a MPR the node with highest N_willingness among
               the nodes in N with non-zero reachability.  In case of
               multiple choice select the node which provides
               reachability to the maximum number of nodes in N2.  In
               case of multiple nodes providing the same amount of
               reachability, select the node as MPR whose D(y) is
               greater.  Remove the nodes from N2 which are now covered
               by a node in the MPR set.

</p><p class="rfcparagraph">     5    A node's MPR set is generated from the union of the MPR sets
          for each interface.  As an optimization, process each node, y,
          in the MPR set in increasing order of N_willingness.  If all
          nodes in N2 are still covered by at least one node in the MPR
          set excluding node y, and if N_willingness of node y is
          smaller than WILL_ALWAYS, then node y MAY be removed from the
          MPR set.

</p><p class="rfcparagraph">   Other algorithms, as well as improvements over this algorithm, are
   possible.  For example, assume that in a multiple-interface scenario
   there exists more than one link between nodes 'a' and 'b'.  If node
   'a' has selected node 'b' as MPR for one of its interfaces, then node
   'b' can be selected as MPR without additional performance loss by any
   other interfaces on node 'a'.

</p><p class="rfcparagraph">	<a name="section-8.4"><h3>8.4   Populating the MPR Selector Set</h3></a>

   The MPR selector set of a node, n, is populated by the main addresses
   of the nodes which have selected n as MPR.  MPR selection is signaled
   through HELLO messages.

</p><p class="rfcparagraph">	<a name="section-8.4.1"><h4>8.4.1   HELLO Message Processing</h4></a>

   Upon receiving a HELLO message, if a node finds one of its own
   interface addresses in the list with a Neighbor Type equal to
   MPR_NEIGH, information from the HELLO message must be recorded in the
   MPR Selector Set.

</p><p class="rfcparagraph">   The "validity time" MUST be computed from the Vtime field of the
   message header (see section 3.3.2).  The MPR Selector Set SHOULD then
   be updated as follows:
     1    If there exists no MPR selector tuple with:

</p><p class="rfcparagraph">                    MS_main_addr   == Originator Address

               then a new tuple is created with:

</p><p class="rfcparagraph">                    MS_main_addr   =  Originator Address

     2    The tuple (new or otherwise) with

               MS_main_addr   == Originator Address

          is then modified as follows:

</p><p class="rfcparagraph">               MS_time        =  current time + validity time.

</p><p class="rfcparagraph">   Deletion of MPR selector tuples occurs in case of expiration of the
   timer or in case of link breakage as described in the "Neighborhood
   and 2-hop Neighborhood Changes".

</p><p class="rfcparagraph">	<a name="section-8.5"><h3>8.5   Neighborhood and 2-hop Neighborhood Changes</h3></a>

   A change in the neighborhood is detected when:

</p><p class="rfcparagraph">     -    The L_SYM_time field of a link tuple expires.  This is
          considered as a neighbor loss if the link described by the
          expired tuple was the last link with a neighbor node (on the
          contrary, a link with an interface may break while a link with
          another interface of the neighbor node remains without being
          observed as a neighborhood change).

</p><p class="rfcparagraph">     -    A new link tuple is inserted in the Link Set with a non
          expired L_SYM_time or a tuple with expired L_SYM_time is
          modified so that L_SYM_time becomes non-expired.  This is
          considered as a neighbor appearance if there was previously no
          link tuple describing a link with the corresponding neighbor
          node.

</p><p class="rfcparagraph">   A change in the 2-hop neighborhood is detected when a 2-hop neighbor
   tuple expires or is deleted according to section 8.2.

</p><p class="rfcparagraph">   The following processing occurs when changes in the neighborhood or
   the 2-hop neighborhood are detected:

</p><p class="rfcparagraph">     -    In case of neighbor loss, all 2-hop tuples with
          N_neighbor_main_addr == Main Address of the neighbor MUST be
          deleted.
     -    In case of neighbor loss, all MPR selector tuples with
          MS_main_addr == Main Address of the neighbor MUST be deleted

     -    The MPR set MUST be re-calculated when a neighbor appearance
          or loss is detected, or when a change in the 2-hop
          neighborhood is detected.

</p><p class="rfcparagraph">     -    An additional HELLO message MAY be sent when the MPR set
          changes.

</p><p class="rfcparagraph">	<a name="section-9"><h2>9.   Topology Discovery</h2></a>

   The link sensing and neighbor detection part of the protocol
   basically offers, to each node, a list of neighbors with which it can
   communicate directly and, in combination with the Packet Format and
   Forwarding part, an optimized flooding mechanism through MPRs.  Based
   on this, topology information is disseminated through the network.
   The present section describes which part of the information given by
   the link sensing and neighbor detection is disseminated to the entire
   network and how it is used to construct routes.

</p><p class="rfcparagraph">   Routes are constructed through advertised links and links with
   neighbors.  A node must at least disseminate links between itself and
   the nodes in its MPR-selector set, in order to provide sufficient
   information to enable routing.

</p><p class="rfcparagraph">	<a name="section-9.1"><h3>9.1   TC Message Format</h3></a>

   The proposed format of a TC message is as follows:

</p><p class="rfcparagraph">       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |              ANSN             |           Reserved            |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |               Advertised Neighbor Main Address                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |               Advertised Neighbor Main Address                |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ...                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   This is sent as the data-portion of the general message format with
   the "Message Type" set to TC_MESSAGE.  The time to live SHOULD be set
   to 255 (maximum value) to diffuse the message into the entire network
   and Vtime set accordingly to the value of TOP_HOLD_TIME, as specified
   in section 18.3.
     Advertised Neighbor Sequence Number (ANSN)

          A sequence number is associated with the advertised neighbor
          set.  Every time a node detects a change in its advertised
          neighbor set, it increments this sequence number ("Wraparound"
          is handled as described in section 19).  This number is sent
          in this ANSN field of the TC message to keep track of the most
          recent information.  When a node receives a TC message, it can
          decide on the basis of this Advertised Neighbor Sequence
          Number, whether or not the received information about the
          advertised neighbors of the originator node is more recent
          than what it already has.

</p><p class="rfcparagraph">     Advertised Neighbor Main Address

          This field contains the main address of a neighbor node.  All
          main addresses of the advertised neighbors of the Originator
          node are put in the TC message.  If the maximum allowed
          message size (as imposed by the network) is reached while
          there are still advertised neighbor addresses which have not
          been inserted into the TC-message, more TC messages will be
          generated until the entire advertised neighbor set has been
          sent.  Extra main addresses of neighbor nodes may be included,
          if redundancy is desired.

</p><p class="rfcparagraph">     Reserved

          This field is reserved, and MUST be set to "0000000000000000"
          for compliance with this document.

</p><p class="rfcparagraph">	<a name="section-9.2"><h3>9.2   Advertised Neighbor Set</h3></a>

   A TC message is sent by a node in the network to declare a set of
   links, called advertised link set which MUST include at least the
   links to all nodes of its MPR Selector set, i.e., the neighbors which
   have selected the sender node as a MPR.

</p><p class="rfcparagraph">   If, for some reason, it is required to distribute redundant TC
   information, refer to section 15.

</p><p class="rfcparagraph">   The sequence number (ANSN) associated with the advertised neighbor
   set is also sent with the list.  The ANSN number MUST be incremented
   when links are removed from the advertised neighbor set; the ANSN
   number SHOULD be incremented when links are added to the advertised
   neighbor set.
	<a name="section-9.3"><h3>9.3   TC Message Generation</h3></a>

   In order to build the topology information base, each node, which has
   been selected as MPR, broadcasts Topology Control (TC) messages.  TC
   messages are flooded to all nodes in the network and take advantage
   of MPRs.  MPRs enable a better scalability in the distribution of
   topology information [1].

</p><p class="rfcparagraph">   The list of addresses can be partial in each TC message (e.g., due to
   message size limitations, imposed by the network), but parsing of all
   TC messages describing the advertised link set of a node MUST be
   complete within a certain refreshing period (TC_INTERVAL).  The
   information diffused in the network by these TC messages will help
   each node calculate its routing table.

</p><p class="rfcparagraph">   When the advertised link set of a node becomes empty, this node
   SHOULD still send (empty) TC-messages during the a duration equal to
   the "validity time" (typically, this will be equal to TOP_HOLD_TIME)
   of its previously emitted TC-messages, in order to invalidate the
   previous TC-messages.  It SHOULD then stop sending TC-messages until
   some node is inserted in its advertised link set.

</p><p class="rfcparagraph">   A node MAY transmit additional TC-messages to increase its
   reactiveness to link failures.  When a change to the MPR selector set
   is detected and this change can be attributed to a link failure, a
   TC-message SHOULD be transmitted after an interval shorter than
   TC_INTERVAL.

</p><p class="rfcparagraph">	<a name="section-9.4"><h3>9.4   TC Message Forwarding</h3></a>

   TC messages are broadcast and retransmitted by the MPRs in order to
   diffuse the messages in the entire network.  TC messages MUST be
   forwarded according to the "default forwarding algorithm" (described
   in section 3.4).

</p><p class="rfcparagraph">	<a name="section-9.5"><h3>9.5   TC Message Processing</h3></a>

   Upon receiving a TC message, the "validity time" MUST be computed
   from the Vtime field of the message header (see section 3.3.2).  The
   topology set SHOULD then be updated as follows (using section 19 for
   comparison of ANSN):

</p><p class="rfcparagraph">     1    If the sender interface (NB: not originator) of this message
          is not in the symmetric 1-hop neighborhood of this node, the
          message MUST be discarded.
     2    If there exist some tuple in the topology set where:

</p><p class="rfcparagraph">               T_last_addr == originator address AND

               T_seq       >  ANSN,

          then further processing of this TC message MUST NOT be
          performed and the message MUST be silently discarded (case:
          message received out of order).

</p><p class="rfcparagraph">
     3    All tuples in the topology set where:

</p><p class="rfcparagraph">               T_last_addr == originator address AND

               T_seq       <  ANSN

          MUST be removed from the topology set.

</p><p class="rfcparagraph">     4    For each of the advertised neighbor main address received in
          the TC message:

</p><p class="rfcparagraph">          4.1  If there exist some tuple in the topology set where:

</p><p class="rfcparagraph">                    T_dest_addr == advertised neighbor main address, AND

                    T_last_addr == originator address,

               then the holding time of that tuple MUST be set to:

</p><p class="rfcparagraph">                    T_time      =  current time + validity time.

</p><p class="rfcparagraph">          4.2  Otherwise, a new tuple MUST be recorded in the topology
               set where:

</p><p class="rfcparagraph">                    T_dest_addr = advertised neighbor main address,

                    T_last_addr = originator address,

                    T_seq       = ANSN,

                    T_time      = current time + validity time.
	<a name="section-10"><h2>10.   Routing Table Calculation</h2></a>

   Each node maintains a routing table which allows it to route data,
   destined for the other nodes in the network.  The routing table is
   based on the information contained in the local link information base
   and the topology set.  Therefore, if any of these sets are changed,
   the routing table is recalculated to update the route information
   about each destination in the network.  The route entries are
   recorded in the routing table in the following format:

</p><p class="rfcparagraph">         1.  R_dest_addr    R_next_addr    R_dist   R_iface_addr
         2.  R_dest_addr    R_next_addr    R_dist   R_iface_addr
         3.      ,,             ,,           ,,          ,,

   Each entry in the table consists of R_dest_addr, R_next_addr, R_dist,
   and R_iface_addr.  Such entry specifies that the node identified by
   R_dest_addr is estimated to be R_dist hops away from the local node,
   that the symmetric neighbor node with interface address R_next_addr
   is the next hop node in the route to R_dest_addr, and that this
   symmetric neighbor node is reachable through the local interface with
   the address R_iface_addr.  Entries are recorded in the routing table
   for each destination in the network for which a route is known.  All
   the destinations, for which a route is broken or only partially
   known, are not recorded in the table.

</p><p class="rfcparagraph">   More precisely, the routing table is updated when a change is
   detected in either:

</p><p class="rfcparagraph">     -    the link set,

     -    the neighbor set,

     -    the 2-hop neighbor set,

     -    the topology set,

     -    the Multiple Interface Association Information Base,

   More precisely, the routing table is recalculated in case of neighbor
   appearance or loss, when a 2-hop tuple is created or removed, when a
   topology tuple is created or removed or when multiple interface
   association information changes.  The update of this routing
   information does not generate or trigger any messages to be
   transmitted, neither in the network, nor in the 1-hop neighborhood.

</p><p class="rfcparagraph">   To construct the routing table of node X, a shortest path algorithm
   is run on the directed graph containing the arcs X -> Y where Y is
   any symmetric neighbor of X (with Neighbor Type equal to SYM), the
   arcs Y -> Z where Y is a neighbor node with willingness different of
   WILL_NEVER and there exists an entry in the 2-hop Neighbor set with Y
   as N_neighbor_main_addr and Z as N_2hop_addr, and the arcs U -> V,
   where there exists an entry in the topology set with V as T_dest_addr
   and U as T_last_addr.

</p><p class="rfcparagraph">   The following procedure is given as an example to calculate (or
   recalculate) the routing table:

</p><p class="rfcparagraph">     1    All the entries from the routing table are removed.

</p><p class="rfcparagraph">     2    The new routing entries are added starting with the
          symmetric neighbors (h=1) as the destination nodes. Thus, for
          each neighbor tuple in the neighbor set where:

</p><p class="rfcparagraph">               N_status   = SYM

          (there is a symmetric link to the neighbor), and for each
          associated link tuple of the neighbor node such that L_time >=
          current time, a new routing entry is recorded in the routing
          table with:

</p><p class="rfcparagraph">               R_dest_addr  = L_neighbor_iface_addr, of the
                              associated link tuple;

</p><p class="rfcparagraph">               R_next_addr  = L_neighbor_iface_addr, of the
                              associated link tuple;

</p><p class="rfcparagraph">               R_dist       = 1;

</p><p class="rfcparagraph">               R_iface_addr = L_local_iface_addr of the
                              associated link tuple.

</p><p class="rfcparagraph">          If in the above, no R_dest_addr is equal to the main address
          of the neighbor, then another new routing entry with MUST be
          added, with:

</p><p class="rfcparagraph">               R_dest_addr  = main address of the neighbor;

</p><p class="rfcparagraph">               R_next_addr  = L_neighbor_iface_addr of one of the
                              associated link tuple with L_time >=
               current time;

</p><p class="rfcparagraph">               R_dist       = 1;

</p><p class="rfcparagraph">               R_iface_addr = L_local_iface_addr of the
                              associated link tuple.
     3    for each node in N2, i.e., a 2-hop neighbor which is not a
          neighbor node or the node itself, and such that there exist at
          least one entry in the 2-hop neighbor set where
          N_neighbor_main_addr correspond to a neighbor node with
          willingness different of WILL_NEVER, one selects one 2-hop
          tuple and creates one entry in the routing table with:

</p><p class="rfcparagraph">               R_dest_addr  =  the main address of the 2-hop neighbor;

</p><p class="rfcparagraph">               R_next_addr  = the R_next_addr of the entry in the
                              routing table with:

</p><p class="rfcparagraph">                                  R_dest_addr == N_neighbor_main_addr
                                                 of the 2-hop tuple;

</p><p class="rfcparagraph">               R_dist       = 2;

</p><p class="rfcparagraph">               R_iface_addr = the R_iface_addr of the entry in the
                              routing table with:

</p><p class="rfcparagraph">                                  R_dest_addr == N_neighbor_main_addr
                                                 of the 2-hop tuple;

</p><p class="rfcparagraph">
     3    The new route entries for the destination nodes h+1 hops away
          are recorded in the routing table.  The following procedure
          MUST be executed for each value of h, starting with h=2 and
          incrementing it by 1 each time.  The execution will stop if no
          new entry is recorded in an iteration.

</p><p class="rfcparagraph">          3.1  For each topology entry in the topology table, if its
               T_dest_addr does not correspond to R_dest_addr of any
               route entry in the routing table AND its T_last_addr
               corresponds to R_dest_addr of a route entry whose R_dist
               is equal to h, then a new route entry MUST be recorded in
               the routing table (if it does not already exist) where:

</p><p class="rfcparagraph">                    R_dest_addr  = T_dest_addr;

</p><p class="rfcparagraph">                    R_next_addr  = R_next_addr of the recorded
                                   route entry where:

</p><p class="rfcparagraph">                                   R_dest_addr == T_last_addr

                    R_dist       = h+1; and
                    R_iface_addr = R_iface_addr of the recorded
                                   route entry where:

</p><p class="rfcparagraph">                                      R_dest_addr == T_last_addr.

</p><p class="rfcparagraph">          3.2  Several topology entries may be used to select a next hop
               R_next_addr for reaching the node R_dest_addr.  When h=1,
               ties should be broken such that nodes with highest
               willingness and MPR selectors are preferred as next hop.

</p><p class="rfcparagraph">     4    For each entry in the multiple interface association base
          where there exists a routing entry such that:

</p><p class="rfcparagraph">               R_dest_addr  == I_main_addr  (of the multiple interface
                                            association entry)

          AND there is no routing entry such that:

</p><p class="rfcparagraph">               R_dest_addr  == I_iface_addr

          then a route entry is created in the routing table with:

</p><p class="rfcparagraph">               R_dest_addr  =  I_iface_addr (of the multiple interface
                                             association entry)

               R_next_addr  =  R_next_addr  (of the recorded
                                             route entry)

               R_dist       =  R_dist       (of the recorded
                                             route entry)

               R_iface_addr =  R_iface_addr (of the recorded
                                                route entry).

</p><p class="rfcparagraph">	<a name="section-11"><h2>11.   Node Configuration</h2></a>

   This section outlines how a node should be configured, in order to
   operate in an OLSR MANET.

</p><p class="rfcparagraph">	<a name="section-11.1"><h3>11.1   Address Assignment</h3></a>

   The nodes in the MANET network SHOULD be assigned addresses within a
   defined address sequence, i.e., the nodes in the MANET SHOULD be
   addressable through a network address and a netmask.
   Likewise, the nodes in each associated network SHOULD be assigned
   addresses from a defined address sequence, distinct from that being
   used in the MANET.

</p><p class="rfcparagraph">	<a name="section-11.2"><h3>11.2   Routing Configuration</h3></a>

   Any MANET node with associated networks or hosts SHOULD be configured
   such that it has routes set up to the interfaces with associated
   hosts or network.

</p><p class="rfcparagraph">	<a name="section-11.3"><h3>11.3   Data Packet Forwarding</h3></a>

   OLSR itself does not perform packet forwarding.  Rather, it maintains
   the routing table in the underlying operating system, which is
   assumed to be forwarding packets as specified in RFC1812.

</p><p class="rfcparagraph">	<a name="section-12"><h2>12.   Non OLSR Interfaces</h2></a>

   A node MAY be equipped with multiple interfaces, some of which do not
   participate in the OLSR MANET.  These non OLSR interfaces may be
   point to point connections to other singular hosts or may connect to
   separate networks.

</p><p class="rfcparagraph">   In order to provide connectivity from the OLSR MANET interface(s) to
   these non OLSR interface(s), a node SHOULD be able to inject external
   route information to the OLSR MANET.

</p><p class="rfcparagraph">   Injecting routing information from the OLSR MANET to non OLSR
   interfaces is outside the scope of this specification.  It should be
   clear, however, that the routing information for the OLSR MANET can
   be extracted from the topology table (see section 4.4) or directly
   from the routing table of OLSR, and SHOULD be injected onto the non
   OLSR interfaces following whatever mechanism (routing protocol,
   static configuration etc.) is provided on these interfaces.

</p><p class="rfcparagraph">   An example of such a situation could be where a node is equipped with
   a fixed network (e.g., an Ethernet) connecting to a larger network as
   well as a wireless network interface running OLSR.

</p><p class="rfcparagraph">   Notice that this is a different case from that of "multiple
   interfaces", where all the interfaces are participating in the MANET
   through running the OLSR protocol.

</p><p class="rfcparagraph">   In order to provide this capability of injecting external routing
   information into an OLSR MANET, a node with such non-MANET interfaces
   periodically issues a Host and Network Association (HNA) message,
   containing sufficient information for the recipients to construct an
   appropriate routing table.
	<a name="section-12.1"><h3>12.1   HNA Message Format</h3></a>

   The proposed format of an HNA-message is:

</p><p class="rfcparagraph">       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Network Address                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Netmask                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                         Network Address                       |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                             Netmask                           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                              ...                              |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

   This is sent as the data part of the general packet format with the
   "Message Type" set to HNA_MESSAGE, the TTL field set to 255 and Vtime
   set accordingly to the value of HNA_HOLD_TIME, as specified in
   section 18.3.

</p><p class="rfcparagraph">     Network Address

          The network address of the associated network

     Netmask

          The netmask, corresponding to the network address immediately
          above.

</p><p class="rfcparagraph">	<a name="section-12.2"><h3>12.2   Host and Network Association Information Base</h3></a>

   Each node maintains information concerning which nodes may act as
   "gateways" to associated hosts and networks by recording "association
   tuples" (A_gateway_addr, A_network_addr, A_netmask, A_time), where
   A_gateway_addr is the address of an OLSR interface of the gateway,
   A_network_addr and A_netmask specify the network address and netmask
   of a network, reachable through this gateway, and A_time specifies
   the time at which this tuple expires and hence *MUST* be removed.

</p><p class="rfcparagraph">   The set of all association tuples in a node is called the
   "association set".

</p><p class="rfcparagraph">   It should be noticed, that the HNA-message can be considered as a
   "generalized version" of the TC-message: the originator of both the
   HNA- and TC-messages announce "reachability" to some other host(s).
   In the TC-message, no netmask is required, since all reachability is
   announced on a per-host basis.  In HNA-messages, announcing
   reachability to an address sequence through a network- and netmask
   address is typically preferred over announcing reachability to
   individual host addresses.

</p><p class="rfcparagraph">   An important difference between TC- and HNA-messages is, that a TC
   message may have a canceling effect on previous information (if the
   ANSN is incremented), whereas information in HNA-messages is removed
   only upon expiration.

</p><p class="rfcparagraph">	<a name="section-12.3"><h3>12.3   HNA Message Generation</h3></a>

   A node with associated hosts and/or networks SHOULD periodically
   generate a Host and Network Association (HNA) message, containing
   pairs of (network address, netmask) corresponding to the connected
   hosts and networks.  HNA-messages SHOULD be transmitted periodically
   every HNA_INTERVAL.  The Vtime is set accordingly to the value of
   HNA_HOLD_TIME, as specified in section 18.3.

</p><p class="rfcparagraph">   A node without any associated hosts and/or networks SHOULD NOT
   generate HNA-messages.

</p><p class="rfcparagraph">	<a name="section-12.4"><h3>12.4   HNA Message Forwarding</h3></a>

   Upon receiving a HNA message, and thus following the rules of section
   3, in this version of the specification, the message MUST be
   forwarded according to section 3.4.

</p><p class="rfcparagraph">	<a name="section-12.5"><h3>12.5   HNA Message Processing</h3></a>

   In this section, the term "originator address" is used to designate
   the main address on the OLSR MANET of the node which originally
   issued the HNA-message.

</p><p class="rfcparagraph">   Upon processing a HNA-message, the "validity time" MUST be computed
   from the Vtime field of the message header (see section 3.3.2).  The
   association base SHOULD then be updated as follows:

</p><p class="rfcparagraph">   1    If the sender interface (NB: not originator) of this message
        is not in the symmetric 1-hop neighborhood of this node, the
        message MUST be discarded.

</p><p class="rfcparagraph">   2    Otherwise, for each (network address, netmask) pair in the
        message:
        2.1  if an entry in the association set already exists, where:

</p><p class="rfcparagraph">                  A_gateway_addr == originator address

                  A_network_addr == network address

                  A_netmask      == netmask

             then the holding time for that tuple MUST be set to:

</p><p class="rfcparagraph">                  A_time         =  current time + validity time


        2.2  otherwise, a new tuple MUST be recorded with:

</p><p class="rfcparagraph">                  A_gateway_addr =  originator address

                  A_network_addr =  network address

                  A_netmask      =  netmask

                  A_time         =  current time + validity time

	<a name="section-12.6"><h3>12.6   Routing Table Calculation</h3></a>

   In addition to the routing table computation as described in section
   10, the host and network association set MUST be added as follows:

</p><p class="rfcparagraph">   For each tuple in the association set,

     1    If there is no entry in the routing table with:

</p><p class="rfcparagraph">               R_dest_addr     == A_network_addr/A_netmask

          then a new routing entry is created.

</p><p class="rfcparagraph">     2    If a new routing entry was created at the previous step, or
          else if there existed one with:

</p><p class="rfcparagraph">               R_dest_addr     == A_network_addr/A_netmask


               R_dist          >  dist to A_gateway_addr of
                                  current association set tuple,

          then the routing entry is modified as follows:

</p><p class="rfcparagraph">               R_dest_addr     =  A_network_addr/A_netmask
               R_next_addr     =  the next hop on the path
                                  from the node to A_gateway_addr

               R_dist          =  dist to A_gateway_addr

               R_next_addr and R_iface_addr MUST be set to the same
               values as the tuple from the routing set with R_dest_addr
               == A_gateway_addr.

</p><p class="rfcparagraph">	<a name="section-12.7"><h3>12.7   Interoperability Considerations</h3></a>

   Nodes, which do not implement support for non OLSR interfaces, can
   coexist in a network with nodes which do implement support for non
   OLSR interfaces: the generic packet format and message forwarding
   (section 3) ensures that HNA messages are correctly forwarded by all
   nodes.  Nodes which implement support for non OLSR interfaces may
   thus transmit and process HNA messages according to this section.

</p><p class="rfcparagraph">   Nodes, which do not implement support for non OLSR interfaces can not
   take advantage of the functionality specified in this section,
   however they will forward HNA messages correctly, as specified in
   section 3.

</p><p class="rfcparagraph">	<a name="section-13"><h2>13.   Link Layer Notification</h2></a>

   OLSR is designed not to impose or expect any specific information
   from the link layer.  However, if information from the link-layer
   describing link breakage is available, a node MAY use this as
   described in this section.

</p><p class="rfcparagraph">   If link layer information describing connectivity to neighboring
   nodes is available (i.e., loss of connectivity such as through
   absence of a link layer acknowledgment), this information is used in
   addition to the information from the HELLO-messages to maintain the
   neighbor information base and the MPR selector set.

</p><p class="rfcparagraph">   Thus, upon receiving a link-layer notification that the link between
   a node and a neighbor interface is broken, the following actions are
   taken with respect to link sensing:

</p><p class="rfcparagraph">   Each link tuple in the local link set SHOULD, in addition to what is
   described in section 4.2, include a L_LOST_LINK_time field.
   L_LOST_LINK_time is a timer for declaring a link as lost when an
   established link becomes pending.  (Notice, that this is a subset of
   what is recommended in section 14, thus link hysteresis and link
   layer notifications can coexist).
   HELLO message generation should consider those new fields as follows:

</p><p class="rfcparagraph">     1    if L_LOST_LINK_time is not expired, the link is advertised
          with a link type of LOST_LINK.  In addition, it is not
          considered as a symmetric link in the updates of the
          associated neighbor tuple (see section 8.1).

</p><p class="rfcparagraph">     2    if the link to a neighboring symmetric or asymmetric interface
          is broken, the corresponding link tuple is modified:
          L_LOST_LINK_time and L_time are set to current time +
          NEIGHB_HOLD_TIME.

</p><p class="rfcparagraph">     3    this is considered as a link loss and the appropriate
          processing described in section 8.5 should be
          performed.

</p><p class="rfcparagraph">	<a name="section-13.1"><h3>13.1   Interoperability Considerations</h3></a>

   Link layer notifications provide, for a node, an additional criterion
   by which a node may determine if a link to a neighbor node is lost.
   Once a link is detected as lost, it is advertised, in accordance with
   the provisions described in the previous sections of this
   specification.

</p><p class="rfcparagraph">	<a name="section-14"><h2>14.   Link Hysteresis</h2></a>

   Established links should be as reliable as possible to avoid data
   packet loss.  This implies that link sensing should be robust against
   bursty loss or transient connectivity between nodes.  Hence, to
   enhance the robustness of the link sensing mechanism, the following
   implementation recommendations SHOULD be considered.

</p><p class="rfcparagraph">	<a name="section-14.1"><h3>14.1   Local Link Set</h3></a>

   Each link tuple in the local link set SHOULD, in addition to what is
   described in section 4.2, include a L_link_pending field, a
   L_link_quality field, and a L_LOST_LINK_time field.  L_link_pending
   is a boolean value specifying if the link is considered pending
   (i.e., the link is not considered established).  L_link_quality is a
   dimensionless number between 0 and 1 describing the quality of the
   link.  L_LOST_LINK_time is a timer for declaring a link as lost when
   an established link becomes pending.
	<a name="section-14.2"><h3>14.2   Hello Message Generation</h3></a>

   HELLO message generation should consider those new fields as follows:

</p><p class="rfcparagraph">     1    if L_LOST_LINK_time is not expired, the link is advertised
          with a link type of LOST_LINK.

</p><p class="rfcparagraph">     2    otherwise, if L_LOST_LINK_time is expired and L_link_pending
          is set to "true", the link SHOULD NOT be advertised at all;

</p><p class="rfcparagraph">     3    otherwise, if L_LOST_LINK_time is expired and L_link_pending
          is set to "false", the link is advertised as described
          previously in section 6.

</p><p class="rfcparagraph">   A node considers that it has a symmetric link for each link tuple
   where:

</p><p class="rfcparagraph">     1    L_LOST_LINK_time is expired, AND

     2    L_link_pending is "false", AND

     3    L_SYM_time is not expired.

</p><p class="rfcparagraph">   This definition for "symmetric link" SHOULD be used in updating the
   associated neighbor tuple (see section 8.1) for computing the
   N_status of a neighbor node.  This definition SHOULD thereby also be
   used as basis for the symmetric neighborhood when computing the MPR
   set, as well as for "the symmetric neighbors" in the first steps of
   the routing table calculation.

</p><p class="rfcparagraph">   Apart from the above, what has been described previously does not
   interfere with the advanced link sensing fields in the link tuples.
   The L_link_quality, L_link_pending and L_LOST_LINK_time fields are
   exclusively updated according to the present section.  This section
   does not modify the function of any other fields in the link tuples.

</p><p class="rfcparagraph">	<a name="section-14.3"><h3>14.3   Hysteresis Strategy</h3></a>

   The link between a node and some of its neighbor interfaces might be
   "bad", i.e., from time to time let HELLOs pass through only to fade
   out immediately after.  In this case, the neighbor information base
   would contain a bad link for at least "validity time".  The following
   hysteresis strategy SHOULD be adopted to counter this situation.

</p><p class="rfcparagraph">   For each neighbor interface NI heard by interface I, the
   L_link_quality field of the corresponding Link Tuple determines the
   establishment of the link.  The value of L_link_quality is compared
   to two thresholds HYST_THRESHOLD_HIGH, HYST_THRESHOLD_LOW, fixed
   between 0 and 1 and such that HYST_THRESHOLD_HIGH >=
   HYST_THRESHOLD_LOW.

</p><p class="rfcparagraph">   The L_link_pending field is set according to the following:

</p><p class="rfcparagraph">     1    if L_link_quality > HYST_THRESHOLD_HIGH:

</p><p class="rfcparagraph">               L_link_pending   = false

               L_LOST_LINK_time = current time - 1 (expired)

     2    otherwise, if L_link_quality < HYST_THRESHOLD_LOW:

</p><p class="rfcparagraph">               L_link_pending   = true

               L_LOST_LINK_time = min (L_time, current time +
               NEIGHB_HOLD_TIME)

               (the link is then considered as lost according to section
               8.5 and this may produce a neighbor loss).

</p><p class="rfcparagraph">     3    otherwise, if HYST_THRESHOLD_LOW <= L_link_quality
                                           <= HYST_THRESHOLD_HIGH:

</p><p class="rfcparagraph">               L_link_pending and L_LOST_LINK_time remain unchanged.

</p><p class="rfcparagraph">   The condition for considering a link established is thus stricter
   than the condition for dropping a link.  Notice thus, that a link can
   be dropped based on either timer expiration (as described in section
   7) or on L_link_quality dropping below HYST_THRESHOLD_LOW.

</p><p class="rfcparagraph">   Also notice, that even if a link is not considered as established by
   the link hysteresis, the link tuples are still updated for each
   received HELLO message (as described in section 7).  Specifically,
   this implies that, regardless of whether or not the link hysteresis
   considers a link as "established", tuples in the link set do not
   expire except as determined by the L_time field of the link tuples.

</p><p class="rfcparagraph">   As a basic implementation requirement, an estimation of the link
   quality must be maintained and stored in the L_link_quality field.
   If some measure of the signal/noise level on a received message is
   available (e.g., as a link layer notification), then it can be used
   as estimation after normalization.

</p><p class="rfcparagraph">   If no signal/noise information or other link quality information is
   available from the link layer, an algorithm such as the following can
   be utilized (it is an exponentially smoothed moving average of the
   transmission success rate).  The algorithm is parameterized by a
   scaling parameter HYST_SCALING which is a number fixed between 0 and
   1.  For each neighbor interface NI heard by interface I, the first
   time NI is heard by I, L_link_quality is set to HYST_SCALING
   (L_link_pending is set to true and L_LOST_LINK_time to current time -
   1).

</p><p class="rfcparagraph">   A tuple is updated according to two rules.  Every time an OLSR packet
   emitted by NI is received by I, the stability rule is applied:

</p><p class="rfcparagraph">          L_link_quality = (1-HYST_SCALING)*L_link_quality
                           + HYST_SCALING.

</p><p class="rfcparagraph">     When an OLSR packet emitted by NI is lost by I, the instability
     rule is applied:

</p><p class="rfcparagraph">          L_link_quality = (1-HYST_SCALING)*L_link_quality.

</p><p class="rfcparagraph">   The loss of OLSR packet is detected by tracking the missing Packet
   Sequence Numbers on a per interface basis and by "long period of
   silence" from a node.  A "long period of silence may be detected
   thus: if no OLSR packet has been received on interface I from
   interface NI during HELLO emission interval of interface NI (computed
   from the Htime field in the last HELLO message received from NI), a
   loss of an OLSR packet is detected.

</p><p class="rfcparagraph">	<a name="section-14.4"><h3>14.4   Interoperability Considerations</h3></a>

   Link hysteresis determines, for a node, the criteria at which a link
   to a neighbor node is accepted or rejected.  Nodes in a network may
   have different criteria, according to the nature of the media over
   which they are communicating.  Once a link is accepted, it is
   advertised, in accordance with the provisions described in the
   previous sections of this specification.

</p><p class="rfcparagraph">	<a name="section-15"><h2>15.   Redundant Topology Information</h2></a>

   In order to provide redundancy to topology information base, the
   advertised link set of a node MAY contain links to neighbor nodes
   which are not in MPR selector set of the node.  The advertised link
   set MAY contain links to the whole neighbor set of the node.  The
   minimal set of links that any node MUST advertise in its TC messages
   is the links to its MPR selectors.  The advertised link set can be
   built according to the following rule based on a local parameter
   called TC_REDUNDANCY parameter.
	<a name="section-15.1"><h3>15.1   TC_REDUNDANCY Parameter</h3></a>

   The parameter TC_REDUNDANCY specifies, for the local node, the amount
   of information that MAY be included in the TC messages.  The
   parameter SHOULD be interpreted as follows:

</p><p class="rfcparagraph">     -    if the TC_REDUNDANCY parameter of the node is 0, then the
          advertised link set of the node is limited  to the MPR
          selector set (as described in section 8.3),

     -    if the TC_REDUNDANCY parameter of the node is 1, then the
          advertised link set of the node is the union of its MPR set
          and its MPR selector set,

     -    if the TC_REDUNDANCY parameter of the node is 2, then the
          advertised link set of the node is the full neighbor link set.

</p><p class="rfcparagraph">   A node with willingness equal to WILL_NEVER SHOULD have TC_REDUNDANCY
   also equal to zero.

</p><p class="rfcparagraph">	<a name="section-15.2"><h3>15.2   Interoperability Considerations</h3></a>

   A TC message is sent by a node in the network to declare a set of
   links, called advertised link set, which MUST include at least the
   links to all nodes of its MPR Selector set, i.e., the neighbors which
   have selected the sender node as a MPR.  This is sufficient
   information to ensure that routes can be computed in accordance with
   section 10.

</p><p class="rfcparagraph">   The provisions in this section specifies how additional information
   may be declared, as specified through a TC_REDUNDANCY parameter.
   TC_REDUNDANCY = 0 implies that the information declared corresponds
   exactly to the MPR Selector set, identical to section 9.  Other
   values of TC_REDUNDANCY specifies additional information to be
   declared, i.e., the contents of the MPR Selector set is always
   declared.  Thus, nodes with different values of TC_REDUNDANCY may
   coexist in a network: control messages are carried by all nodes in
   accordance with section 3, and all nodes will receive at least the
   link-state information required to construct routes as described in
   section 10.

</p><p class="rfcparagraph">	<a name="section-16"><h2>16.   MPR Redundancy</h2></a>

   MPR redundancy specifies the ability for a node to select redundant
   MPRs.  Section 4.5 specifies that a node should select its MPR set to
   be as small as possible, in order to reduce protocol overhead.  The
   criteria for selecting MPRs is, that all strict 2-hop nodes must be
   reachable through, at least, one MPR node.  Redundancy of the MPR set
   affects the overhead through affecting the amount of links being
   advertised, the amount of nodes advertising links and the efficiency
   of the MPR flooding mechanism.  On the other hand, redundancy in the
   MPR set ensures that reachability for a node is advertised by more
   nodes, thus additional links are diffused to the network.

</p><p class="rfcparagraph">   While, in general, a minimal MPR set provides the least overhead,
   there are situations in which overhead can be traded off for other
   benefits.  For example, a node may decide to increase its MPR
   coverage if it observes many changes in its neighbor information base
   caused by mobility, while otherwise keeping a low MPR coverage.

</p><p class="rfcparagraph">	<a name="section-16.1"><h3>16.1   MPR_COVERAGE Parameter</h3></a>

   The MPR coverage is defined by a single local parameter,
   MPR_COVERAGE, specifying by how many MPR nodes any strict 2-hop node
   should be covered.  MPR_COVERAGE=1 specifies that the overhead of the
   protocol is kept at a minimum and causes the MPR selection to operate
   as described in section 8.3.1.  MPR_COVERAGE=m ensures that, if
   possible, a node selects its MPR set such that all strict 2-hop nodes
   for an interface are reachable through at least m MPR nodes on that
   interface.  MPR_COVERAGE can assume any integer value > 0.  The
   heuristic MUST be applied per interface, I.  The MPR set for a node
   is the union of the MPR sets found for each interface.

</p><p class="rfcparagraph">   Notice that MPR_COVERAGE can be tuned locally without affecting the
   consistency of the protocol.  For example, nodes in a network may
   operate with different values of MPR_COVERAGE.

</p><p class="rfcparagraph">	<a name="section-16.2"><h3>16.2   MPR Computation</h3></a>

   Using MPR coverage, the MPR selection heuristics is extended from
   that described in the section 8.3.1 by one definition:

</p><p class="rfcparagraph">     Poorly covered node:

</p><p class="rfcparagraph">          A poorly covered node is a node in N2 which is covered by less
          than MPR_COVERAGE nodes in N.

</p><p class="rfcparagraph">   The proposed heuristic for selecting MPRs is then as follows:

</p><p class="rfcparagraph">     1    Start with an MPR set made of all members of N with
          willingness equal to WILL_ALWAYS

     2    Calculate D(y), where y is a member of N, for all nodes in N.
     3    Select as MPRs those nodes in N which cover the poorly covered
          nodes in N2.  The nodes are then removed from N2 for the rest
          of the computation.

</p><p class="rfcparagraph">     4    While there exist nodes in N2 which are not covered by at
          least MPR_COVERAGE nodes in the MPR set:

</p><p class="rfcparagraph">          4.1  For each node in N, calculate the reachability, i.e.,
               the number of nodes in N2 which are not yet covered
               by at least MPR_COVERAGE nodes in the MPR set, and
               which are reachable through this 1-hop neighbor;

</p><p class="rfcparagraph">          4.2  Select as a MPR the node with highest willingness among
               the nodes in N with non-zero reachability.  In case of
               multiple choice select the node which provides
               reachability to the maximum number of nodes in N2.  In
               case of multiple nodes providing the same amount of
               reachability, select the node as MPR whose D(y) is
               greater.  Remove the nodes from N2 which are now covered
               by MPR_COVERAGE nodes in the MPR set.

</p><p class="rfcparagraph">     5    A node's MPR set is generated from the union of the MPR sets
          for each interface.  As an optimization, process each node, y,
          in the MPR set in increasing order of N_willingness.  If all
          nodes in N2 are still covered by at least MPR_COVERAGE nodes
          in the MPR set excluding node y, and if N_willingness of node
          y is smaller than WILL_ALWAYS, then node y MAY be removed from
          the MPR set.

</p><p class="rfcparagraph">   When the MPR set has been computed, all the corresponding main
   addresses are stored in the MPR Set.

</p><p class="rfcparagraph">	<a name="section-16.3"><h3>16.3   Interoperability Considerations</h3></a>

   The MPR set of a node MUST, according to section 8.3, be calculated
   by a node in such a way that it, through the neighbors in the MPR-
   set, can reach all symmetric strict 2-hop neighbors.  This is
   achieved by the heuristics in this section, for all values of
   MPR_COVERAGE > 0.  MPR_COVERAGE is a local parameter for each node.
   Setting this parameter affects only the amount of redundancy in part
   of the network.

</p><p class="rfcparagraph">   Notice that for MPR_COVERAGE=1, the heuristics in this section is
   identical to the heuristics specified in the section 8.3.1.
   Nodes with different values of MPR_COVERAGE may coexist in a network:
   control messages are carried by all nodes in accordance with section
   3, and all nodes will receive at least the link-state information
   required to construct routes as described in sections 9 and 10.

</p><p class="rfcparagraph">	<a name="section-17"><h2>17.   IPv6 Considerations</h2></a>

   All the operations and parameters described in this document used by
   OLSR for IP version 4 are the same as those used by OLSR for IP
   version 6.  To operate with IP version 6, the only required change is
   to replace the IPv4 addresses with IPv6 address.  The minimum packet
   and message sizes (under which there is rejection) should be adjusted
   accordingly, considering the greater size of IPv6 addresses.

</p><p class="rfcparagraph">	<a name="section-18"><h2>18.   Proposed Values for Constants</h2></a>

   This section list the values for the constants used in the
   description of the protocol.

</p><p class="rfcparagraph">	<a name="section-18.1"><h3>18.1   Setting emission intervals and holding times</h3></a>

   The proposed constant for C is the following:

</p><p class="rfcparagraph">          C = 1/16 seconds (equal to 0.0625 seconds)

   C is a scaling factor for the "validity time" calculation ("Vtime"
   and "Htime" fields in message headers, see section 18.3).  The
   "validity time" advertisement is designed such that nodes in a
   network may have different and individually tuneable emission
   intervals, while still interoperate fully.  For protocol functioning
   and interoperability to work:

</p><p class="rfcparagraph">     -    the advertised holding time MUST always be greater than the
          refresh interval of the advertised information.  Moreover, it
          is recommended that the relation between the interval (from
          section 18.2), and the hold time is kept as specified
          in section 18.3, to allow for reasonable packet loss.

</p><p class="rfcparagraph">     -    the constant C SHOULD be set to the suggested value.  In order
          to achieve interoperability, C MUST be the same on all nodes.

</p><p class="rfcparagraph">     -    the emission intervals (section 18.2), along with the
          advertised holding times (subject to the above constraints)
          MAY be selected on a per node basis.

</p><p class="rfcparagraph">   Note that the timer resolution of a given implementation might not be
   sufficient to wake up the system on precise refresh times or on
   precise expire times: the implementation SHOULD round up the
   'validity time' ("Vtime" and "Htime" of packets) to compensate for
   coarser timer resolution, at least in the case where "validity time"
   could be shorter than the sum of emission interval and maximum
   expected timer error.

</p><p class="rfcparagraph">	<a name="section-18.2"><h3>18.2   Emission Intervals</h3></a>

          HELLO_INTERVAL        = 2 seconds

          REFRESH_INTERVAL      = 2 seconds

          TC_INTERVAL           = 5 seconds

          MID_INTERVAL          = TC_INTERVAL

          HNA_INTERVAL          = TC_INTERVAL

	<a name="section-18.3"><h3>18.3   Holding Time</h3></a>

          NEIGHB_HOLD_TIME      = 3 x REFRESH_INTERVAL

          TOP_HOLD_TIME         = 3 x TC_INTERVAL

          DUP_HOLD_TIME         = 30 seconds

          MID_HOLD_TIME         = 3 x MID_INTERVAL

          HNA_HOLD_TIME         = 3 x HNA_INTERVAL

   The Vtime in the message header (see section 3.3.2), and the Htime in
   the HELLO message (see section 6.1) are the fields which hold
   information about the above values in mantissa and exponent format
   (rounded up).  In other words:

</p><p class="rfcparagraph">     value = C*(1+a/16)*2^b [in seconds]

   where a is the integer represented by the four highest bits of the
   field and b the integer represented by the four lowest bits of the
   field.

</p><p class="rfcparagraph">   Notice, that for the previous proposed value of C, (1/16 seconds),
   the values, in seconds, expressed by the formula above can be stored,
   without loss of precision, in binary fixed point or floating point
   numbers with at least 8 bits of fractional part.  This corresponds
   with NTP time-stamps and single precision IEEE Standard 754 floating
   point numbers.
   Given one of the above holding times, a way of computing the
   mantissa/exponent representation of a number T (of seconds) is the
   following:

</p><p class="rfcparagraph">     -    find the largest integer 'b' such that: T/C >= 2^b

     -    compute the expression 16*(T/(C*(2^b))-1), which may not be a
          integer, and round it up.  This results in the value for 'a'

     -    if 'a' is equal to 16: increment 'b' by one, and set 'a' to 0

     -    now, 'a' and 'b' should be integers between 0 and 15, and the
          field will be a byte holding the value a*16+b

   For instance, for values of 2 seconds, 6 seconds, 15 seconds, and 30
   seconds respectively, a and b would be: (a=0,b=5), (a=8,b=6),
   (a=14,b=7) and (a=14,b=8) respectively.

</p><p class="rfcparagraph">	<a name="section-18.4"><h3>18.4   Message Types</h3></a>

          HELLO_MESSAGE         = 1

          TC_MESSAGE            = 2

          MID_MESSAGE           = 3

          HNA_MESSAGE           = 4

	<a name="section-18.5"><h3>18.5   Link Types</h3></a>

          UNSPEC_LINK           = 0

          ASYM_LINK             = 1

          SYM_LINK              = 2

          LOST_LINK             = 3

	<a name="section-18.6"><h3>18.6   Neighbor Types</h3></a>

          NOT_NEIGH             = 0

          SYM_NEIGH             = 1

          MPR_NEIGH             = 2
	<a name="section-18.7"><h3>18.7   Link Hysteresis</h3></a>

          HYST_THRESHOLD_HIGH   = 0.8

          HYST_THRESHOLD_LOW    = 0.3

          HYST_SCALING          = 0.5

	<a name="section-18.8"><h3>18.8   Willingness</h3></a>

          WILL_NEVER            = 0

          WILL_LOW              = 1

          WILL_DEFAULT          = 3

          WILL_HIGH             = 6

          WILL_ALWAYS           = 7

   The willingness of a node may be set to any integer value from 0 to
   7, and specifies how willing a node is to be forwarding traffic on
   behalf of other nodes.  Nodes will, by default, have a willingness
   WILL_DEFAULT.  WILL_NEVER indicates a node which does not wish to
   carry traffic for other nodes, for example due to resource
   constraints (like being low on battery).  WILL_ALWAYS indicates that
   a node always should be selected to carry traffic on behalf of other
   nodes, for example due to resource abundance (like permanent power
   supply, high capacity interfaces to other nodes).

</p><p class="rfcparagraph">   A node may dynamically change its willingness as its conditions
   change.

</p><p class="rfcparagraph">   One possible application would, for example, be for a node, connected
   to a permanent power supply and with fully charged batteries, to
   advertise a willingness of WILL_ALWAYS.  Upon being disconnected from
   the permanent power supply (e.g., a PDA being taken out of its
   charging cradle), a willingness of WILL_DEFAULT is advertised.  As
   battery capacity is drained, the willingness would be further
   reduced.  First to the intermediate value between WILL_DEFAULT and
   WILL_LOW, then to WILL_LOW and finally to WILL_NEVER, when the
   battery capacity of the node does no longer support carrying foreign
   traffic.
	<a name="section-18.9"><h3>18.9   Misc. Constants</h3></a>

          TC_REDUNDANCY         = 0


          MPR COVERAGE          = 1


          MAXJITTER             = HELLO_INTERVAL / 4

	<a name="section-19"><h2>19.   Sequence Numbers</h2></a>

   Sequence numbers are used in OLSR with the purpose of discarding
   "old" information, i.e., messages received out of order.  However
   with a limited number of bits for representing sequence numbers,
   wrap-around (that the sequence number is incremented from the maximum
   possible value to zero) will occur.  To prevent this from interfering
   with the operation of the protocol, the following MUST be observed.

</p><p class="rfcparagraph">   The term MAXVALUE designates in the following the largest possible
   value for a sequence number.

</p><p class="rfcparagraph">   The sequence number S1 is said to be "greater than" the sequence
   number S2 if:

</p><p class="rfcparagraph">          S1 > S2 AND S1 - S2 <= MAXVALUE/2 OR

          S2 > S1 AND S2 - S1 > MAXVALUE/2

   Thus when comparing two messages, it is possible - even in the
   presence of wrap-around - to determine which message contains the
   most recent information.

</p><p class="rfcparagraph">	<a name="section-20"><h2>20.   Security Considerations</h2></a>

   Currently, OLSR does not specify any special security measures.  As a
   proactive routing protocol, OLSR makes a target for various attacks.
   The various possible vulnerabilities are discussed in this section.

</p><p class="rfcparagraph">	<a name="section-20.1"><h3>20.1   Confidentiality</h3></a>

   Being a proactive protocol, OLSR periodically diffuses topological
   information.  Hence, if used in an unprotected wireless network, the
   network topology is revealed to anyone who listens to OLSR control
   messages.
   In situations where the confidentiality of the network topology is of
   importance, regular cryptographic techniques such as exchange of OLSR
   control traffic messages encrypted by PGP [9] or encrypted by some
   shared secret key can be applied to ensure that control traffic can
   be read and interpreted by only those authorized to do so.

</p><p class="rfcparagraph">	<a name="section-20.2"><h3>20.2   Integrity</h3></a>

   In OLSR, each node is injecting topological information into the
   network through transmitting HELLO messages and, for some nodes, TC
   messages.  If some nodes for some reason, malicious or malfunction,
   inject invalid control traffic, network integrity may be compromised.
   Therefore, message authentication is recommended.

</p><p class="rfcparagraph">   Different such situations may occur, for instance:

</p><p class="rfcparagraph">     1    a node generates TC (or HNA) messages, advertising links to
          non-neighbor nodes:

</p><p class="rfcparagraph">     2    a node generates TC (or HNA) messages, pretending to be
          another node,

     3    a node generates HELLO messages, advertising non-neighbor
          nodes,

     4    a node generates HELLO messages, pretending to be another
          node.

</p><p class="rfcparagraph">     5    a node forwards altered control messages,

     6    a node does not broadcast control messages,

     7    a node does not select multipoint relays correctly.

</p><p class="rfcparagraph">     8    a node forwards broadcast control messages unaltered, but does
          not forward unicast data traffic;

</p><p class="rfcparagraph">     9    a node "replays" previously recorded control traffic from
          another node.

</p><p class="rfcparagraph">   Authentication of the originator node for control messages (for
   situation 2, 4 and 5) and on the individual links announced in the
   control messages (for situation 1 and 3) may be used as a
   countermeasure.  However to prevent nodes from repeating old (and
   correctly authenticated) information (situation 9) temporal
   information is required, allowing a node to positively identify such
   delayed messages.
   In general, digital signatures and other required security
   information may be transmitted as a separate OLSR message type,
   thereby allowing that "secured" and "unsecured" nodes can coexist in
   the same network, if desired.

</p><p class="rfcparagraph">   Specifically, the authenticity of entire OLSR control messages can be
   established through employing IPsec authentication headers, whereas
   authenticity of individual links (situation 1 and 3) require
   additional security information to be distributed.

</p><p class="rfcparagraph">   An important consideration is, that all control messages in OLSR are
   transmitted either to all nodes in the neighborhood (HELLO messages)
   or broadcast to all nodes in the network (e.g., TC messages).

</p><p class="rfcparagraph">   For example, a control message in OLSR is always a point-to-
   multipoint transmission.  It is therefore important that the
   authentication mechanism employed permits that any receiving node can
   validate the authenticity of a message.  As an analogy, given a block
   of text, signed by a PGP private key, then anyone with the
   corresponding public key can verify the authenticity of the text.

</p><p class="rfcparagraph">	<a name="section-20.3"><h3>20.3   Interaction with External Routing Domains</h3></a>

   OLSR does, through the HNA messages specified in section 12, provide
   a basic mechanism for injecting external routing information to the
   OLSR domain.  Section 12 also specifies that routing information can
   be extracted from the topology table or the routing table of OLSR
   and, potentially, injected into an external domain if the routing
   protocol governing that domain permits.

</p><p class="rfcparagraph">   Other than as described in the section 20.2, when operating nodes,
   connecting OLSR to an external routing domain, care MUST be taken not
   to allow potentially insecure and un-trustworthy information to be
   injected from the OLSR domain to external routing domains.  Care MUST
   be taken to validate the correctness of information prior to it being
   injected as to avoid polluting routing tables with invalid
   information.

</p><p class="rfcparagraph">   A recommended way of extending connectivity from an existing routing
   domain to an OLSR routed MANET is to assign an IP prefix (under the
   authority of the nodes/gateways connecting the MANET with the exiting
   routing domain) exclusively to the OLSR MANET area, and to configure
   the gateways statically to advertise routes to that IP sequence to
   nodes in the existing routing domain.
	<a name="section-20.4"><h3>20.4   Node Identity</h3></a>

   OLSR does not make any assumption about node addresses, other than
   that each node is assumed to have a unique IP address.

</p><p class="rfcparagraph">	<a name="section-21"><h2>21.   Flow and congestion control</h2></a>

   Due to its proactive nature, the OLSR protocol has a natural control
   over the flow of its control traffic.  Nodes transmits control
   message at predetermined rates fixed by predefined refresh intervals.
   Furthermore the MPR optimization greatly saves on control overhead,
   and this is done on two sides.  First, the packets that advertise the
   topology are much shorter since only MPR selectors may be advertised.
   Second, the cost of flooding this information is greatly reduced
   since only MPR nodes forward the broadcast packets.  In dense
   networks, the reduction of control traffic can be of several orders
   of magnitude compared to routing protocols using classical flooding
   (such as OSPF) [10].  This feature naturally provides more bandwidth
   for useful data traffic and pushes further the frontier of
   congestion.  Since the control traffic is continuous and periodic, it
   keeps more stable the quality of the links used in routing, where
   reactive protocols, with bursty floodings for route discoveries and
   repairs, may damage the link qualities for short times by causing
   numerous collisions on those links, possibly provoking route repair
   cascades.  However, in certain OLSR options, some control messages
   may be intentionally sent in advance of their deadline(TC or Hello
   messages) in order to increase the reactiveness of the protocol
   against topology changes.  This may cause a small, temporary and
   local increase of control traffic.

</p><p class="rfcparagraph">	<a name="section-22"><h2>22.   IANA Considerations</h2></a>

   OLSR defines a "Message Type" field for control messages.  A new
   registry has been created for the values for this Message Type field,
   and the following values assigned:

</p><p class="rfcparagraph">       Message Type             Value
      --------------------      -----
       HELLO_MESSAGE              1
       TC_MESSAGE                 2
       MID_MESSAGE                3
       HNA_MESSAGE                4

   Future values in the range 5-127 of the Message Type can be allocated
   using standards action [7].

</p><p class="rfcparagraph">   Additionally, values in the range 128-255 are reserved for
   private/local use.
	<a name="section-23"><h2>23.   Acknowledgments</h2></a>

   The authors would like to thank Joseph Macker
   <macker@itd.nrl.navy.mil> and his team, including Justin Dean
   <jdean@itd.nrl.navy.mil>, for their valuable suggestions on the
   advanced neighbor sensing mechanism and other various aspects of the
   protocol, including careful review of the protocol specification.

</p><p class="rfcparagraph">   The authors would also like to thank Christopher Dearlove
   <chris.dearlove@baesystems.com> for valuable input on the MPR
   selection heuristics and for careful reviews of the protocol
   specification.

</p><p class="rfcparagraph">	<a name="section-24"><h2>24.   Contributors</h2></a>

   During the development of this specification, the following list of
   people contributed.  The contributors are listed alphabetically.

</p><p class="rfcparagraph">   Cedric Adjih
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5215
   EMail: Cedric.Adjih@inria.fr


   Thomas Heide Clausen
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5133
   EMail: T.Clausen@computer.org


   Philippe Jacquet
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5263
   EMail: Philippe.Jacquet@inria.fr
   Anis Laouiti
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5088
   EMail: Anis.Laouiti@inria.fr


   Pascale Minet
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5233
   EMail: Pascale.Minet@inria.fr


   Paul Muhlethaler
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5278
   EMail: Paul.Muhlethaler@inria.fr


   Amir Qayyum
   Center for Advanced Research in Engineering Pvt. Ltd.
   19 Ataturk Avenue
   Islamabad, Pakistan

   Phone: +92-51-2874115
   EMail: amir@carepvtltd.com


   Laurent Viennot
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5225
   EMail: Laurent.Viennot@inria.fr
	<a name="section-25"><h2>25.   References</h2></a>

	<a name="section-25.1"><h3>25.1   Normative References</h3></a>

   [5]   Bradner, S., "Key words for use in RFCs to Indicate Requirement
         Levels", BCP 14, RFC 2119, March 1997.

</p><p class="rfcparagraph">   [7]   T.  Clausen, P.  Jacquet, A.  Laouiti, P.  Muhlethaler, A.
         Qayyum and L.  Viennot.  Optimized Link State Routing Protocol.
         IEEE INMIC Pakistan 2001.

</p><p class="rfcparagraph">	<a name="section-25.2"><h3>25.2   Informative References</h3></a>

   [1]   P. Jacquet, P. Minet, P. Muhlethaler, N. Rivierre.  Increasing
         reliability in cable free radio LANs: Low level forwarding in
         HIPERLAN.  Wireless Personal Communications, 1996.

</p><p class="rfcparagraph">   [2]   A.  Qayyum, L.  Viennot, A.  Laouiti.  Multipoint relaying: An
         efficient technique for flooding in mobile wireless networks.
         35th Annual Hawaii International Conference on System Sciences
         (HICSS'2001).

</p><p class="rfcparagraph">   [3]   ETSI STC-RES10 Committee.  Radio equipment and systems:
         HIPERLAN type 1, functional specifications ETS 300-652, ETSI,
         June 1996.

</p><p class="rfcparagraph">   [4]   P. Jacquet and L. Viennot, Overhead in Mobile Ad-hoc Network
         Protocols, INRIA research report RR-3965, 2000.

</p><p class="rfcparagraph">   [6]   T. Clausen, G. Hansen, L. Christensen and G. Behrmann.  The
         Optimized Link State Routing Protocol, Evaluation through
         Experiments and Simulation.  IEEE Symposium on "Wireless
         Personal Mobile Communications", September 2001.

</p><p class="rfcparagraph">   [8]   Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA
         Considerations Section in RFCs",  BCP 26, RFC 2434, October
         1998.

</p><p class="rfcparagraph">   [9]   Atkins, D., Stallings, W. and P. Zimmermann, "PGP Message
         Exchange Formats", RFC 1991, August 1996.

</p><p class="rfcparagraph">   [10]  P. Jacquet, A. Laouiti, P. Minet, L. Viennot.  Performance
         analysis of OLSR multipoint relay flooding in two ad hoc
         wireless network models, INRIA research report RR-4260, 2001.
	<a name="section-26"><h2>26.   Authors' Addresses</h2></a>

   Thomas Heide Clausen
   Project HIPERCOM
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5133
   EMail: T.Clausen@computer.org


   Philippe Jacquet,
   Project HIPERCOM,
   INRIA Rocquencourt, BP 105
   78153 Le Chesnay Cedex, France

   Phone: +33 1 3963 5263,
   EMail: Philippe.Jacquet@inria.fr
	<a name="section-27"><h2>27.   Full Copyright Statement</h2></a>

   Copyright (C) The Internet Society (2003).  All Rights Reserved.<br>

</p><p class="rfcparagraph">   This document and translations of it may be copied and furnished to
   others, and derivative works that comment on or otherwise explain it
   or assist in its implementation may be prepared, copied, published
   and distributed, in whole or in part, without restriction of any
   kind, provided that the above copyright notice and this paragraph are
   included on all such copies and derivative works.  However, this
   document itself may not be modified in any way, such as by removing
   the copyright notice or references to the Internet Society or other
   Internet organizations, except as needed for the purpose of
   developing Internet standards in which case the procedures for
   copyrights defined in the Internet Standards process must be
   followed, or as required to translate it into languages other than
   English.

</p><p class="rfcparagraph">   The limited permissions granted above are perpetual and will not be
   revoked by the Internet Society or its successors or assignees.

</p><p class="rfcparagraph">   This document and the information contained herein is provided on an
   "AS IS" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING
   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION
   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF
   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

</p><p class="rfcparagraph">Acknowledgement

   Funding for the RFC Editor function is currently provided by the
   Internet Society.

</p>

















Clausen & Jacquet             Experimental                     [Page 75]


      </td>
      <td class=code>
        <div class='highlight'>
            <!--
            <b>Related Stack Overflow questions:</b>
            <ul>
                
            </ul>
            -->
        </div>
      </td>
    </tr>
  </table>
</div>
</body>